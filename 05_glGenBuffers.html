<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title></title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="reveal.js/css/reveal.min.css"/>
    <style type="text/css">code{white-space: pre;}</style>
    <link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">
    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
      if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
      }
    </script>
    <!--[if lt IE 9]>
    <script src="reveal.js/lib/js/html5shiv.js"></script>
    <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">


<section><section id="apitrace---generate-buffers" class="titleslide slide level1"><h1>Apitrace - Generate Buffers</h1></section><section id="glgenbuffers" class="slide level2">
<h1>glGenBuffers</h1>
<ul>
<li><p><a href="https://github.com/shearer12345/graphics_examples_in_git_branches/blob/glTraingleWhiteWithApiTrace/main.cpp#L243">main.cpp line 243 in our C++ code</a></p>
<pre class="c++"><code>glGenBuffers(1, &amp;positionBufferObject);</code></pre></li>
<li><a href="https://www.opengl.org/sdk/docs/man4/html/glGenBuffers.xhtml">glGenBuffers</a> generate buffer object names</li>
<li>returns n buffer object names in buffers</li>
<li><p>in this case only 1 name is asked for, and return, the ID of buffer object is <strong>1</strong></p></li>
</ul>
<figure>
<img src="assets/apitrace/05_glGenBuffers/01_glGenBuffers.png" alt="01_glGenBuffers.png" /><figcaption>01_glGenBuffers.png</figcaption>
</figure>
</section><section id="glgenbuffers---context" class="slide level2">
<h1>glGenBuffers - context</h1>
<ul>
<li>new buffer objects (in this case just 1) are created</li>
<li>the buffer object is empty</li>
<li>the <strong>ID/name</strong> for the buffer object is stored in the address passed in</li>
<li>nothing else has changed</li>
</ul>
<p>TODO - diagram of context, based on <img src="assets/apitrace/context_draft_placeholder.jpg" alt="assets/apitrace/context_draft.jpg" /></p>
</section><section id="glbindbuffer" class="slide level2">
<h1>glBindBuffer</h1>
<ul>
<li><p><a href="https://github.com/shearer12345/graphics_examples_in_git_branches/blob/glTraingleWhiteWithApiTrace/main.cpp#L245">main.cpp line 245 in our C++ code</a></p>
<pre class="c++"><code>glBindBuffer(GL_ARRAY_BUFFER, positionBufferObject);</code></pre></li>
<li><a href="https://www.opengl.org/sdk/docs/man4/html/glBindBuffer.xhtml">glBindBuffer</a> binds a buffer object to the specified buffer binding point</li>
<li>in this case the buffer object is ID=<strong>1</strong> (our positionBufferObject) is bound as the GL_ARRAY_BUFFER
<ul>
<li>you can see this change in the OpenGL state (parameters tab)</li>
</ul></li>
</ul>
<figure>
<img src="assets/apitrace/05_glGenBuffers/02_glBindBuffer.png" alt="02_glBindBuffer.png" /><figcaption>02_glBindBuffer.png</figcaption>
</figure>
</section><section id="glbindbuffer---context" class="slide level2">
<h1>glBindBuffer - context</h1>
<ul>
<li>the <strong>GL_ARRAY_BUFFER_BINDING</strong> is now set to <strong>1</strong></li>
<li>nothing else has changed</li>
</ul>
<p>TODO - diagram of context, based on <img src="assets/apitrace/context_draft_placeholder.jpg" alt="assets/apitrace/context_draft.jpg" /></p>
</section><section id="glbufferdata" class="slide level2">
<h1>glBufferData</h1>
<ul>
<li><p><a href="https://github.com/shearer12345/graphics_examples_in_git_branches/blob/glTraingleWhiteWithApiTrace/main.cpp#L246">main.cpp line 246 in our C++ code</a></p>
<pre class="c++"><code>glBufferData(GL_ARRAY_BUFFER, sizeof(vertexPositions), vertexPositions, GL_STATIC_DRAW);</code></pre></li>
<li><a href="https://www.opengl.org/sdk/docs/man4/html/glBufferData.xhtml">glBufferData</a> creates and initializes a buffer object's data store.</li>
<li>Takes 4 parameters:
<ul>
<li>target</li>
<li>size</li>
<li>data</li>
<li>usage</li>
</ul></li>
<li>Note the <strong>Vertex Data</strong> tab that now shows in ApiTrace
<ul>
<li>It is the <strong>glBufferData</strong> call that <strong>copies</strong> our CPU data to OpenGL</li>
<li>This data is now visible in the debugger
<ul>
<li>Note: it is just 48 bytes, we can choose how to interpret it</li>
</ul></li>
<li>These are detailed more in the next section</li>
</ul></li>
</ul>
<figure>
<img src="assets/apitrace/05_glGenBuffers/03_glBufferData.png" alt="03_glBufferData.png" /><figcaption>03_glBufferData.png</figcaption>
</figure>
</section><section id="glbufferdata-parameters" class="slide level2">
<h1>glBufferData (parameters)</h1>
<ul>
<li>GLenum target
<ul>
<li>Specifies the target to which the buffer object is bound.</li>
<li>In this case = <strong>GL_ARRAY_BUFFER</strong>, which is used to store vertex attributes</li>
</ul></li>
<li>GLsizeiptr size
<ul>
<li>the size in <strong>bytes</strong> of the buffer object's new data store.</li>
<li>in this case <strong>48</strong> bytes (our array has <strong>12 elements</strong>, each of which are <strong>GL_FLOAT</strong>s (each <strong>32-bits </strong>of precision == <strong>4 bytes</strong>) **12*4=48**</li>
</ul></li>
<li>const GLvoid * data
<ul>
<li>a pointer to data that will be <strong>copied</strong> into the data store for initialization, or NULL if no data is to be copied.</li>
<li>in this case, a pointer to the <strong>vertexPositions</strong> array</li>
</ul></li>
<li>GLenum usage
<ul>
<li>the expected usage pattern of the data store</li>
<li>in this case, <strong>GL_STATIC_DRAW</strong>
<ul>
<li>STATIC means <strong>data store contents will be modified once and used many times.</strong></li>
<li>DRAW means <strong>data store contents are modified by the application, and used as the source for GL drawing and image specification commands.</strong></li>
</ul></li>
</ul></li>
<li>you can see this change in the OpenGL state (parameters tab)</li>
</ul>
</section><section id="glbufferdata-byte-interpretation" class="slide level2">
<h1>glBufferData (byte interpretation)</h1>
<ul>
<li>we can choose how the bytes in the buffer object are interpreted in Vertices</li>
<li>we will have to specify this when we want to use the buffer object for rendering</li>
<li>in the following example, ApiTrace is set to interpret vertices as groups of 4 GL_FLOATS, with a 16 byte jump from one group to the next</li>
</ul>
<figure>
<img src="assets/apitrace/05_glGenBuffers/04_glBufferDataByteInterpretation.png" alt="04_glBufferDataByteInterpretation.png" /><figcaption>04_glBufferDataByteInterpretation.png</figcaption>
</figure>
</section><section id="glbufferdata---context" class="slide level2">
<h1>glBufferData - context</h1>
<ul>
<li>new graphics memory is allocated for the buffer</li>
<li>the graphics memory is <strong>filled</strong> with the bytes from <strong>vertexPositions</strong></li>
<li>nothing else has changed
<ul>
<li>specifically, we <strong>have not</strong> told OpenGL <strong>how</strong> to interpret the bytes</li>
</ul></li>
</ul>
<p>TODO - diagram of context, based on <img src="assets/apitrace/context_draft_placeholder.jpg" alt="assets/apitrace/context_draft.jpg" /></p>
</section><section id="glbindbuffer-unbinding" class="slide level2">
<h1>glBindBuffer (unbinding)</h1>
<ul>
<li><p><a href="https://github.com/shearer12345/graphics_examples_in_git_branches/blob/glTraingleWhiteWithApiTrace/main.cpp#L247">main.cpp line 247 in our C++ code</a></p>
<pre class="c++"><code>glBindBuffer(GL_ARRAY_BUFFER, 0);</code></pre></li>
<li><a href="https://www.opengl.org/sdk/docs/man4/html/glBindBuffer.xhtml">glBindBuffer</a> binds a buffer object to the specified buffer binding point</li>
<li>in this case the buffer object is ID=<strong>0</strong>
<ul>
<li><strong>0</strong> has the meaning on <strong>no buffer</strong>, so no buffer is any longer bound</li>
<li>you can see this change in the OpenGL state (parameters tab)
<ul>
<li>GL_ARRAY_BUFFER_BINDING no longer shows as it is back on its default value</li>
</ul></li>
</ul></li>
</ul>
<figure>
<img src="assets/apitrace/05_glGenBuffers/05_glBindBufferUnbind.png" alt="05_glBindBufferUnbind.png" /><figcaption>05_glBindBufferUnbind.png</figcaption>
</figure>
</section><section id="glbindbuffer-unbinding---context" class="slide level2">
<h1>glBindBuffer (unbinding) - context</h1>
<ul>
<li>the <strong>GL_ARRAY_BUFFER_BINDING</strong> is now set to <strong>0</strong> (meaning no buffer)</li>
<li>nothing else has changed</li>
</ul>
<p>TODO - diagram of context, based on <img src="assets/apitrace/context_draft_placeholder.jpg" alt="assets/apitrace/context_draft.jpg" /></p>
</section></section>
    </div>
  </div>


  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.min.js"></script>

  <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,
        theme: 'sky', // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
//          { src: 'reveal.js/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; }, }
//          { src: 'reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
]});
    </script>
    </body>
</html>
