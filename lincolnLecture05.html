<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title></title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="reveal.js/css/reveal.min.css"/>
    <style type="text/css">code{white-space: pre;}</style>
    <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
    </style>
    <link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">
    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
      if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
      }
    </script>
    <!--[if lt IE 9]>
    <script src="reveal.js/lib/js/html5shiv.js"></script>
    <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">


<section><section id="lincoln-lectures-on-graphics---05" class="titleslide slide level1"><h1>Lincoln Lectures On Graphics - 05</h1></section></section>
<section><section id="stepping-through-gltrianglewhite---again" class="titleslide slide level1"><h1>Stepping through glTriangleWhite - again</h1></section><section id="stepping-through-gltrianglewhite-with-apitrace" class="slide level2">
<h1>Stepping through glTriangleWhite with ApiTrace</h1>
<ul>
<li>http://apitrace.github.io/</li>
</ul>
<blockquote>
<p>apitrace consists of a set of tools to: - trace OpenGL, OpenGL ES, Direct3D, and DirectDraw APIs calls to a file - replay the recorded calls from a file, on any machine and, for OpenGL and OpenGL ES, on any operating system - inspect state at any call while replaying - view framebuffers and textures - view call data - edit trace files - profile performance of traces</p>
</blockquote>
</section><section id="apitrace-os-support-matrix" class="slide level2">
<h1>ApiTrace OS support matrix</h1>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">OS</th>
<th style="text-align: left;">Trace</th>
<th style="text-align: left;">CLI</th>
<th style="text-align: left;">GUI</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Android</td>
<td style="text-align: left;">yes</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">Linux</td>
<td style="text-align: left;">yes</td>
<td style="text-align: left;">yes</td>
<td style="text-align: left;">yes</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OS X</td>
<td style="text-align: left;">yes</td>
<td style="text-align: left;">yes</td>
<td style="text-align: left;">yes</td>
</tr>
<tr class="even">
<td style="text-align: left;">Windows</td>
<td style="text-align: left;">yes</td>
<td style="text-align: left;">yes</td>
<td style="text-align: left;">yes</td>
</tr>
</tbody>
</table>
</section></section>
<section><section id="tracing" class="titleslide slide level1"><h1>Tracing</h1></section><section id="tracing-1" class="slide level2">
<h1>Tracing</h1>
<ul>
<li>ApiTrace records the exact calls that are made to the OpenGL library, and the responses from OpenGL</li>
<li>It allows us to step through the trace of a program
<ul>
<li>one <code>gl</code> call at a time</li>
<li>and introspect the <code>gl</code> <strong>state</strong> at that point</li>
</ul></li>
</ul>
</section><section id="tracing---commands" class="slide level2">
<h1>Tracing - commands</h1>
<ul>
<li><p>record a trace</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">apitrace</span> trace bin/3_1_master-debug</code></pre></li>
<li><p>open the trace with the GUI</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">qapitrace</span> 3_1_master-debug.trace</code></pre></li>
</ul>
</section><section id="what-are-we-tracing" class="slide level2">
<h1>What are we tracing?</h1>
<ul>
<li>a moving white triangle on a red background
<ul>
<li><a href="https://github.com/shearer12345/graphics_examples_in_git_branches/tree/glTraingleWhiteWithApiTrace" class="uri">https://github.com/shearer12345/graphics_examples_in_git_branches/tree/glTraingleWhiteWithApiTrace</a></li>
</ul></li>
</ul>
<figure>
<img src="assets/apitrace/3_1_glTraingleWhiteWithApiTrace-debug.trace-2014-10-24_12.13.27.gif" alt="3_1_glTraingleWhiteWithApiTrace-debug.trace" /><figcaption>3_1_glTraingleWhiteWithApiTrace-debug.trace</figcaption>
</figure>
</section><section id="the-actual-trace-is-online-in-the-gltrainglewhitewithapitrace-branch" class="slide level2">
<h1>The actual trace is online, in the glTraingleWhiteWithApiTrace branch</h1>
<ul>
<li>the <a href="https://github.com/shearer12345/graphics_examples_in_git_branches/blob/glTraingleWhiteWithApiTrace/3_1_glTraingleWhiteWithApiTrace-debug.trace">binary trace</a></li>
<li><a href="https://github.com/shearer12345/graphics_examples_in_git_branches/blob/glTraingleWhiteWithApiTrace/3_1_glTraingleWhiteWithApiTrace-debug.trace.txt">text version of the trace</a></li>
</ul>
</section></section>
<section><section id="apitrace---initial-state" class="titleslide slide level1"><h1>Apitrace - Initial state</h1></section><section id="initialisation" class="slide level2">
<h1>Initialisation</h1>
<ul>
<li>Frame 0 contained all the stuff the SDL2 and GLEW did for us
<ul>
<li>e.g. setting of the framebuffer details, asking GL for function pointers</li>
<li>there's nothing interesting for us here</li>
</ul></li>
<li>We'll start look at Frame 1, which as the first call to <strong>GL</strong> that we've made (that we're interested in)</li>
<li>At this point the context (the OpenGL state) is almost brand new</li>
</ul>
</section><section id="initial-state" class="slide level2">
<h1>Initial state</h1>
<ul>
<li>Initially, every variable in the OpenGL state (of <strong>our</strong> context) is set to a default</li>
<li>There are many variables in the OpenGL state.</li>
<li>We are interested in only a small subset</li>
</ul>
</section><section id="apitrace-initially-with-whole-state" class="slide level2">
<h1>ApiTrace initially, with whole state</h1>
<ul>
<li>note the thumbnails on the left are from the <strong>end</strong> of each frame</li>
</ul>
<figure>
<img src="assets/apitrace/01_initial/01_initial_wholeState.png" alt="01_initial_wholeState.png" /><figcaption>01_initial_wholeState.png</figcaption>
</figure>
</section><section id="apitrace-initially-only-showing-non-default-state" class="slide level2">
<h1>ApiTrace initially, only showing non-default state</h1>
<ul>
<li>debug is enabled</li>
<li>we've set the viewport, so viewport and scissor box are set</li>
<li>our window is 600x600, so the viewport covers the whole window
<ul>
<li>we've set the viewport explicitly, to allow apiTrace to replay properly</li>
</ul></li>
</ul>
<figure>
<img src="assets/apitrace/01_initial/02_initial_nonDefaultState.png" alt="02_initial_nonDefaultState.png" /><figcaption>02_initial_nonDefaultState.png</figcaption>
</figure>
</section><section id="apitrace-initially-with-an-unfilled-back-buffer-gl_back" class="slide level2">
<h1>Apitrace initially, with an unfilled back buffer (GL_BACK)</h1>
<ul>
<li>at this point the back buffer hasn't been filled
<ul>
<li>it is just whatever happens to be whatever the GPU has in RAM already in the allocated area <img src="assets/apitrace/01_initial/03_unfilledBackBuffer.png" alt="03_unfilledBackBuffer.png" /></li>
</ul></li>
</ul>
</section><section id="apitrace-initially-with-a-unfilled-back-buffer-gl_back---zoom" class="slide level2">
<h1>Apitrace initially, with a unfilled back buffer (GL_BACK) - ZOOM</h1>
<ul>
<li>large view of the back buffer</li>
<li>filled with random stuff that's being rendered previously</li>
<li><strong>fun days</strong></li>
</ul>
<figure>
<img src="assets/apitrace/01_initial/04_unfilledBackBufferZoom.png" alt="04_unfilledBackBufferZoom.png" /><figcaption>04_unfilledBackBufferZoom.png</figcaption>
</figure>
</section><section id="apitrace-initially-with-no-uniform-variables-set" class="slide level2">
<h1>Apitrace initially, with no <em>uniform</em> variables set</h1>
<ul>
<li>initially no <em>uniform</em> variables are set</li>
</ul>
<figure>
<img src="assets/apitrace/01_initial/05_noUniformsSet.png" alt="05_noUniformsSet.png" /><figcaption>05_noUniformsSet.png</figcaption>
</figure>
</section></section>
<section><section id="apitrace---vertex-shader-creation" class="titleslide slide level1"><h1>Apitrace - Vertex Shader creation</h1></section><section id="glcreateshader-vertex" class="slide level2">
<h1>glCreateShader (vertex)</h1>
<ul>
<li><p><a href="https://github.com/shearer12345/graphics_examples_in_git_branches/blob/glTraingleWhiteWithApiTrace/main.cpp#L158">main.cpp line 158 in our C++ code</a></p>
<pre class="c++"><code>GLuint shader = glCreateShader(eShaderType);</code></pre></li>
<li><a href="https://www.opengl.org/sdk/docs/man4/html/glCreateShader.xhtml">glCreateShader</a> Creates a shader object</li>
<li><p>returns a non-zero value by which it can be referenced</p></li>
</ul>
<figure>
<img src="assets/apitrace/02_glCreateShader_vertex/01_glCreateShaderVertex.png" alt="01_glCreateShaderVertex.png" /><figcaption>01_glCreateShaderVertex.png</figcaption>
</figure>
</section><section id="glcreateshader-vertex---context" class="slide level2">
<h1>glCreateShader (vertex) - context</h1>
<ul>
<li>a new (empty) shader with ID=1 now exists in our context</li>
<li>the shader is empty</li>
<li>nothing else has changed</li>
</ul>
<p>TODO - diagram of context, with a new vertex shader, based on <img src="assets/apitrace/context_draft.jpg" alt="assets/apitrace/context_draft.jpg" /></p>
</section><section id="glshadersource-vertex" class="slide level2">
<h1>glShaderSource (vertex)</h1>
<ul>
<li><p><a href="https://github.com/shearer12345/graphics_examples_in_git_branches/blob/glTraingleWhiteWithApiTrace/main.cpp#L160">main.cpp line 160 in our C++ code</a></p>
<pre class="c++"><code>glShaderSource(shader, 1, &amp;strFileData, NULL);</code></pre></li>
<li><p><a href="https://www.opengl.org/sdk/docs/man4/html/glShaderSource.xhtml">glShaderSource</a> — Replaces the source code in a shader object</p></li>
</ul>
<figure>
<img src="assets/apitrace/02_glCreateShader_vertex/02_glShaderSourceVertex.png" alt="02_glShaderSourceVertex.png" /><figcaption>02_glShaderSourceVertex.png</figcaption>
</figure>
</section><section id="glshadersource-vertex---context" class="slide level2">
<h1>glShaderSource (vertex) - context</h1>
<ul>
<li>the shader with ID=1 is now loaded with source</li>
<li>nothing else has changed</li>
</ul>
<p>TODO - diagram of context, with the vertex shader loaded with the source</p>
</section><section id="glcompileshader-vertex" class="slide level2">
<h1>glCompileShader (vertex)</h1>
<ul>
<li><p><a href="https://github.com/shearer12345/graphics_examples_in_git_branches/blob/glTraingleWhiteWithApiTrace/main.cpp#L162">main.cpp line 162 in our C++ code</a></p>
<pre class="c++"><code>glCompileShader(shader);</code></pre></li>
<li><p><a href="https://www.opengl.org/sdk/docs/man4/html/glCompileShader.xhtml">glCompileShader</a> — Compiles a shader object</p></li>
</ul>
<figure>
<img src="assets/apitrace/02_glCreateShader_vertex/03_glCompileShaderVertex.png" alt="03_glCompileShaderVertex.png" /><figcaption>03_glCompileShaderVertex.png</figcaption>
</figure>
</section><section id="glcompileshader-vertex---context" class="slide level2">
<h1>glCompileShader (vertex) - context</h1>
<ul>
<li>the shader with ID=1 has now been compiled</li>
<li>nothing else has changed</li>
</ul>
<p>TODO - diagram of context, with the vertex shader loaded with the source, and compiled</p>
</section><section id="glgetshaderiv-vertex" class="slide level2">
<h1>glGetShaderiv (vertex)</h1>
<ul>
<li><p><a href="https://github.com/shearer12345/graphics_examples_in_git_branches/blob/glTraingleWhiteWithApiTrace/main.cpp#L165">main.cpp line 165 in our C++ code</a></p>
<pre class="c++"><code>glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;status);</code></pre></li>
<li><a href="https://www.opengl.org/sdk/docs/man4/html/glGetShader.xhtml">glGetShaderiv</a> - returns a parameter from a shader object</li>
<li>in this case the compile status, which is 1 (=ok)</li>
<li>nothing has changed in the context, we just queried it
<ul>
<li>queries are <strong>expensive</strong> (relatively) operations</li>
</ul></li>
</ul>
<figure>
<img src="assets/apitrace/02_glCreateShader_vertex/04_glGetShaderivVertex.png" alt="04_glGetShaderivVertex.png" /><figcaption>04_glGetShaderivVertex.png</figcaption>
</figure>
</section></section>
<section><section id="apitrace---fragment-shader-creation" class="titleslide slide level1"><h1>Apitrace - Fragment Shader creation</h1></section><section id="glcreateshader-fragment" class="slide level2">
<h1>glCreateShader (fragment)</h1>
<ul>
<li><p><a href="https://github.com/shearer12345/graphics_examples_in_git_branches/blob/glTraingleWhiteWithApiTrace/main.cpp#L158">main.cpp line 158 in our C++ code</a></p>
<pre class="c++"><code>GLuint shader = glCreateShader(eShaderType);</code></pre></li>
<li><a href="https://www.opengl.org/sdk/docs/man4/html/glCreateShader.xhtml">glCreateShader</a> Creates a shader object</li>
<li>in this case a fragment shader</li>
<li><p>returns a non-zero value by which it can be referenced</p></li>
</ul>
<p><img src="assets/apitrace/03_glCreateShader_fragment/01_createShaderFragment.png" alt="01_createShaderFragment.png" /> 20:24.png)</p>
</section><section id="glcreateshader-fragment---context" class="slide level2">
<h1>glCreateShader (fragment) - context</h1>
<ul>
<li>a new (empty) shader with ID=2 now exists in our context</li>
<li>the shader is empty</li>
<li>nothing else has changed</li>
</ul>
<p>TODO - diagram of context, with a new fragment shader, based on <img src="assets/apitrace/context_draft.jpg" alt="assets/apitrace/context_draft.jpg" /></p>
</section><section id="glshadersource-fragment" class="slide level2">
<h1>glShaderSource (fragment)</h1>
<ul>
<li><p><a href="https://github.com/shearer12345/graphics_examples_in_git_branches/blob/glTraingleWhiteWithApiTrace/main.cpp#L160">main.cpp line 160 in our C++ code</a></p>
<pre class="c++"><code>glShaderSource(shader, 1, &amp;strFileData, NULL);</code></pre></li>
<li><p><a href="https://www.opengl.org/sdk/docs/man4/html/glShaderSource.xhtml">glShaderSource</a> — Replaces the source code in a shader object</p></li>
</ul>
<figure>
<img src="assets/apitrace/03_glCreateShader_fragment/02_glShaderSourceFragment.png" alt="02_glShaderSourceFragment.png" /><figcaption>02_glShaderSourceFragment.png</figcaption>
</figure>
</section><section id="glshadersource-fragment---context" class="slide level2">
<h1>glShaderSource (fragment) - context</h1>
<ul>
<li>the shader with ID=2 is now loaded with source</li>
<li>nothing else has changed</li>
</ul>
<p>TODO - diagram of context, with the fragment shader loaded with the source</p>
</section><section id="glcompileshader-fragment" class="slide level2">
<h1>glCompileShader (fragment)</h1>
<ul>
<li><p><a href="https://github.com/shearer12345/graphics_examples_in_git_branches/blob/glTraingleWhiteWithApiTrace/main.cpp#L162">main.cpp line 162 in our C++ code</a></p>
<pre class="c++"><code>glCompileShader(shader);</code></pre></li>
<li><p><a href="https://www.opengl.org/sdk/docs/man4/html/glCompileShader.xhtml">glCompileShader</a> — Compiles a shader object</p></li>
</ul>
<figure>
<img src="assets/apitrace/03_glCreateShader_fragment/03_glCompileShaderFragment.png" alt="03_glCompileShaderFragment.png" /><figcaption>03_glCompileShaderFragment.png</figcaption>
</figure>
</section><section id="glcompileshader-fragment---context" class="slide level2">
<h1>glCompileShader (fragment) - context</h1>
<ul>
<li>the shader with ID=2 has now been compiled</li>
<li>nothing else has changed</li>
</ul>
<p>TODO - diagram of context, with the fragment shader loaded with the source, and compiled</p>
</section><section id="glgetshaderiv-fragment" class="slide level2">
<h1>glGetShaderiv (fragment)</h1>
<ul>
<li><p><a href="https://github.com/shearer12345/graphics_examples_in_git_branches/blob/glTraingleWhiteWithApiTrace/main.cpp#L165">main.cpp line 165 in our C++ code</a></p>
<pre class="c++"><code>glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;status);</code></pre></li>
<li><a href="https://www.opengl.org/sdk/docs/man4/html/glGetShader.xhtml">glGetShaderiv</a> - returns a parameter from a shader object</li>
<li>in this case the compile status, which is 1 (=ok)</li>
<li>nothing has changed in the context, we just queried it
<ul>
<li>queries are <strong>expensive</strong> (relatively) operations</li>
</ul></li>
</ul>
<figure>
<img src="assets/apitrace/03_glCreateShader_fragment/04_glGetShaderivFragment.png" alt="04_glGetShaderivFragment.png" /><figcaption>04_glGetShaderivFragment.png</figcaption>
</figure>
</section></section>
<section><section id="apitrace---glsl-program-creation" class="titleslide slide level1"><h1>Apitrace - GLSL program creation</h1></section><section id="glcreateprogram" class="slide level2">
<h1>glCreateProgram</h1>
<ul>
<li><p><a href="https://github.com/shearer12345/graphics_examples_in_git_branches/blob/glTraingleWhiteWithApiTrace/main.cpp#L191">main.cpp line 191 in our C++ code</a></p>
<pre class="c++"><code>GLuint program = glCreateProgram();</code></pre></li>
<li><a href="https://www.opengl.org/sdk/docs/man4/html/glCreateProgram.xhtml">glCreateProgram</a> Creates a program object</li>
<li>returns a non-zero value by which it can be referenced</li>
<li><p>in this case the ID is <strong>3</strong></p></li>
</ul>
<figure>
<img src="assets/apitrace/04_glCreateProgram/01_glCreateProgram.png" alt="01_glCreateProgram.png" /><figcaption>01_glCreateProgram.png</figcaption>
</figure>
</section><section id="glcreateprogram---context" class="slide level2">
<h1>glCreateProgram - context</h1>
<ul>
<li>a new GLSL program with ID=<strong>3</strong> now exists in our context</li>
<li>the program is empty</li>
<li>nothing else has changed</li>
</ul>
<p>TODO - diagram of context, with a new GLSL program, based on <embed src="assets/apitrace/context_draft.jpg_hide" /></p>
</section><section id="glattachshader-vertex" class="slide level2">
<h1>glAttachShader (vertex)</h1>
<ul>
<li><p><a href="https://github.com/shearer12345/graphics_examples_in_git_branches/blob/glTraingleWhiteWithApiTrace/main.cpp#L194">main.cpp line 194 in our C++ code</a></p>
<pre class="c++"><code>glAttachShader(program, shaderList[iLoop]);</code></pre></li>
<li><a href="https://www.opengl.org/sdk/docs/man4/html/glAttachShader.xhtml">glCreateProgram</a> Attaches a shader object to a program object</li>
<li><p>in this case we are attaching to the program with ID=<strong>3</strong>, the shader with ID=<strong>1 (our vertex shader)</strong></p></li>
</ul>
<figure>
<img src="assets/apitrace/04_glCreateProgram/02_glAttachShaderVertex.png" alt="02_glAttachShaderVertex.png" /><figcaption>02_glAttachShaderVertex.png</figcaption>
</figure>
</section><section id="glattachshader-vertex---context" class="slide level2">
<h1>glAttachShader (vertex) - context</h1>
<ul>
<li>our GLSL program with ID=<strong>3</strong> now has our shader with ID=<strong>1 (vertex)</strong> attached</li>
<li>the program is still empty</li>
<li>nothing else has changed</li>
</ul>
<p>TODO - diagram of context, based on [assets/apitrace/context_draft.jpg](assets/apitrace/context_draft.jpg](assets/apitrace/context_draft.jpg_hide)</p>
</section><section id="glattachshader-fragment" class="slide level2">
<h1>glAttachShader (fragment)</h1>
<ul>
<li><p><a href="https://github.com/shearer12345/graphics_examples_in_git_branches/blob/glTraingleWhiteWithApiTrace/main.cpp#L194">main.cpp line 194 in our C++ code</a></p>
<pre class="c++"><code>glAttachShader(program, shaderList[iLoop]);</code></pre></li>
<li><a href="https://www.opengl.org/sdk/docs/man4/html/glAttachShader.xhtml">glCreateProgram</a> Attaches a shader object to a program object</li>
<li><p>in this case we are attaching to the program with ID=<strong>3</strong>, the shader with ID=<strong>2 (our fragment shader)</strong></p></li>
</ul>
<figure>
<img src="assets/apitrace/04_glCreateProgram/03_glAttachShaderFragment.png" alt="03_glAttachShaderFragment.png" /><figcaption>03_glAttachShaderFragment.png</figcaption>
</figure>
</section><section id="glattachshader-fragment---context" class="slide level2">
<h1>glAttachShader (fragment) - context</h1>
<ul>
<li>our GLSL program with ID=<strong>3</strong> now has our shader with ID=<strong>2 (fragment)</strong> attached</li>
<li>the program is still empty</li>
<li>nothing else has changed</li>
</ul>
<p>TODO - diagram of context, based on [assets/apitrace/context_draft.jpg](assets/apitrace/context_draft.jpg](assets/apitrace/context_draft.jpg_hide)</p>
</section><section id="glbindattriblocation" class="slide level2">
<h1>glBindAttribLocation</h1>
<ul>
<li>this call doesn't actually exist in our program - it's been inserted by either SDL or a higher-level part of OpenGL</li>
<li><p><strong>but</strong>, we could have called it ourselves, if we wanted to choose the AttribLocation</p></li>
<li><a href="https://www.opengl.org/sdk/docs/man4/html/glBindAttribLocation.xhtml">glBindAttribLocation</a> Associates a generic vertex attribute index with a named attribute variable</li>
<li><p>in this case associates attribute index <strong>0</strong>, on our program with ID=3, with the GLSL name <strong>position</strong></p></li>
</ul>
<figure>
<img src="assets/apitrace/04_glCreateProgram/04_glBindAttribLocation.png" alt="04_glBindAttribLocation.png" /><figcaption>04_glBindAttribLocation.png</figcaption>
</figure>
</section><section id="glbindattriblocation---context" class="slide level2">
<h1>glBindAttribLocation - context</h1>
<ul>
<li>our GLSL program with ID=<strong>3</strong> now has <strong>position</strong> associated with attribute index <strong>0</strong></li>
<li>the program is still empty</li>
<li>nothing else has changed</li>
</ul>
<p>TODO - diagram of context, based on [assets/apitrace/context_draft.jpg](assets/apitrace/context_draft.jpg](assets/apitrace/context_draft.jpg_hide)</p>
</section><section id="gllinkprogram" class="slide level2">
<h1>glLinkProgram</h1>
<ul>
<li><p><a href="https://github.com/shearer12345/graphics_examples_in_git_branches/blob/glTraingleWhiteWithApiTrace/main.cpp#L196">main.cpp line 196 in our C++ code</a></p>
<pre class="c++"><code>glLinkProgram(program);</code></pre></li>
<li><a href="https://www.opengl.org/sdk/docs/man4/html/glBindAttribLocation.xhtml">glLinkProgram</a> Links a program object</li>
<li>in this case out GLSL program with ID=<strong>3</strong></li>
<li><p>status of the link operation will be stored as part of the program object's state</p></li>
</ul>
<figure>
<img src="assets/apitrace/04_glCreateProgram/05_glLinkProgram.png" alt="05_glLinkProgram.png" /><figcaption>05_glLinkProgram.png</figcaption>
</figure>
</section><section id="gllinkprogram---context" class="slide level2">
<h1>glLinkProgram - context</h1>
<ul>
<li>our GLSL program now has a <strong>linked program</strong> in it, which we need to check the link status of</li>
<li>this program exists separately from the attached shaders</li>
<li>nothing else has changed</li>
</ul>
<p>TODO - diagram of context, based on [assets/apitrace/context_draft.jpg](assets/apitrace/context_draft.jpg](assets/apitrace/context_draft.jpg_hide)</p>
</section><section id="glgetprogramiv" class="slide level2">
<h1>glGetProgramiv</h1>
<ul>
<li><p><a href="https://github.com/shearer12345/graphics_examples_in_git_branches/blob/glTraingleWhiteWithApiTrace/main.cpp#L199">main.cpp line 199 in our C++ code</a></p>
<pre class="c++"><code>glGetProgramiv(program, GL_LINK_STATUS, &amp;status););</code></pre></li>
<li><a href="https://www.opengl.org/sdk/docs/man4/html/glGetProgram.xhtml">glGetProgramiv</a> Returns a parameter from a program object</li>
<li><p>in this case get the GL_LINK_STATUS - if the linking worked</p></li>
</ul>
<figure>
<img src="assets/apitrace/04_glCreateProgram/06_glGetProgramiv.png" alt="06_glGetProgramiv.png" /><figcaption>06_glGetProgramiv.png</figcaption>
</figure>
</section><section id="glgetprogramiv---context" class="slide level2">
<h1>glGetProgramiv - context</h1>
<ul>
<li>no context change - this is a <strong>get</strong> function</li>
<li>remember: <strong>get</strong> functions tend to be relatively expensive</li>
</ul>
</section><section id="gldetachshader-vertex" class="slide level2">
<h1>glDetachShader (vertex)</h1>
<ul>
<li><p><a href="https://github.com/shearer12345/graphics_examples_in_git_branches/blob/glTraingleWhiteWithApiTrace/main.cpp#L212">main.cpp line 212 in our C++ code</a></p>
<pre class="c++"><code>glDetachShader(program, shaderList[iLoop]);</code></pre></li>
<li><a href="https://www.opengl.org/sdk/docs/man4/html/glDetachShader.xhtml">glDetachShader</a> Detaches a shader object from a program object to which it is attached</li>
<li><p>in this case we are detaching from the program with ID=<strong>3</strong>, the shader with ID=<strong>1 (our vertex shader)</strong></p></li>
</ul>
<figure>
<img src="assets/apitrace/04_glCreateProgram/07_glDetachShaderVertex.png" alt="07_glDetachShaderVertex.png" /><figcaption>07_glDetachShaderVertex.png</figcaption>
</figure>
</section><section id="gldetachshader-vertex---context" class="slide level2">
<h1>glDetachShader (vertex) - context</h1>
<ul>
<li>our GLSL program with ID=<strong>3</strong> no longer has our shader with ID=<strong>1 (vertex)</strong> attached</li>
<li>nothing else has changed</li>
</ul>
<p>TODO - diagram of context, based on [assets/apitrace/context_draft.jpg](assets/apitrace/context_draft.jpg](assets/apitrace/context_draft.jpg_hide)</p>
</section><section id="gldetachshader-fragment" class="slide level2">
<h1>glDetachShader (fragment)</h1>
<ul>
<li><p><a href="https://github.com/shearer12345/graphics_examples_in_git_branches/blob/glTraingleWhiteWithApiTrace/main.cpp#L212">main.cpp line 212 in our C++ code</a></p>
<pre class="c++"><code>glDetachShader(program, shaderList[iLoop]);</code></pre></li>
<li><a href="https://www.opengl.org/sdk/docs/man4/html/glDetachShader.xhtml">glDetachShader</a> Detaches a shader object from a program object to which it is attached</li>
<li><p>in this case we are detaching from the program with ID=<strong>3</strong>, the shader with ID=<strong>2 (our fragment shader)</strong></p></li>
</ul>
<figure>
<img src="assets/apitrace/04_glCreateProgram/08_glDetachShaderFragment.png" alt="08_glDetachShaderFragment.png" /><figcaption>08_glDetachShaderFragment.png</figcaption>
</figure>
</section><section id="gldetachshader-fragment---context" class="slide level2">
<h1>glDetachShader (fragment) - context</h1>
<ul>
<li>our GLSL program with ID=<strong>3</strong> no longer has our shader with ID=<strong>2 (fragment)</strong> attached</li>
<li>nothing else has changed</li>
</ul>
<p>TODO - diagram of context, based on [assets/apitrace/context_draft.jpg](assets/apitrace/context_draft.jpg](assets/apitrace/context_draft.jpg_hide)</p>
</section><section id="glgetattriblocation-position" class="slide level2">
<h1>glGetAttribLocation (position)</h1>
<ul>
<li><p><a href="https://github.com/shearer12345/graphics_examples_in_git_branches/blob/glTraingleWhiteWithApiTrace/main.cpp#L235">main.cpp line 235 in our C++ code</a></p>
<pre class="c++"><code>positionLocation = glGetAttribLocation(theProgram, &quot;position&quot;);</code></pre></li>
<li><a href="https://www.opengl.org/sdk/docs/man4/html/glGetAttribLocation.xhtml">glGetAttribLocation</a> Returns the location of an attribute variable</li>
<li>in this case we are getting the location of attribute <strong>position</strong> in the program with ID=<strong>3</strong></li>
<li><p>which is 0</p></li>
</ul>
<figure>
<img src="assets/apitrace/04_glCreateProgram/09_glGetAttribLocation.png" alt="09_glGetAttribLocation.png" /><figcaption>09_glGetAttribLocation.png</figcaption>
</figure>
</section><section id="glgetattriblocation-position---context" class="slide level2">
<h1>glGetAttribLocation (position) - context</h1>
<ul>
<li>this is a <strong>get</strong> function, nothing has changed in the context</li>
</ul>
</section><section id="glgetuniformlocation-offset" class="slide level2">
<h1>glGetUniformLocation (offset)</h1>
<ul>
<li><p><a href="https://github.com/shearer12345/graphics_examples_in_git_branches/blob/glTraingleWhiteWithApiTrace/main.cpp#L236">main.cpp line 236 in our C++ code</a></p>
<pre class="c++"><code>offsetLocation = glGetUniformLocation(theProgram, &quot;offset&quot;);</code></pre></li>
<li><a href="https://www.opengl.org/sdk/docs/man4/html/glGetAttribLocation.xhtml">glGetAttribLocation</a> Returns the location of a uniform variable</li>
<li>in this case we are getting the location of uniform <strong>offset</strong> in the program with ID=<strong>3</strong></li>
<li><p>which is 0</p></li>
</ul>
<figure>
<img src="assets/apitrace/04_glCreateProgram/10_glGetUniformLocation.png" alt="10_glGetUniformLocation.png" /><figcaption>10_glGetUniformLocation.png</figcaption>
</figure>
</section><section id="glgetuniformlocation-offset---context" class="slide level2">
<h1>glGetUniformLocation (offset) - context</h1>
<ul>
<li>this is a <strong>get</strong> function, nothing has changed in the context</li>
</ul>
</section><section id="gldeleteshader-vertex" class="slide level2">
<h1>glDeleteShader (vertex)</h1>
<ul>
<li><p><a href="https://github.com/shearer12345/graphics_examples_in_git_branches/blob/glTraingleWhiteWithApiTrace/main.cpp#L238">main.cpp line 238 in our C++ code</a></p>
<pre class="c++"><code>for_each(shaderList.begin(), shaderList.end(), glDeleteShader);</code></pre></li>
<li><a href="https://www.opengl.org/sdk/docs/man4/html/glDeleteShader.xhtml">glDeleteShader</a> Deletes a shader object</li>
<li>frees the memory and invalidates the name associated with the shader object specified by shader.</li>
<li><p>in this case our shader with ID=<strong>1</strong> (the vertex shader) is deleted</p></li>
</ul>
<figure>
<img src="assets/apitrace/04_glCreateProgram/11_glDeleteShaderVertex.png" alt="11_glDeleteShaderVertex.png" /><figcaption>11_glDeleteShaderVertex.png</figcaption>
</figure>
</section><section id="gldeleteshader-vertex---context" class="slide level2">
<h1>glDeleteShader (vertex) - context</h1>
<ul>
<li>the shader with ID=<strong>1</strong> no longer exists</li>
<li>nothing else has changed</li>
</ul>
<p>TODO - diagram of context, based on <embed src="assets/apitrace/context_draft.jpg_hide" /></p>
</section><section id="gldeleteshader-fragment" class="slide level2">
<h1>glDeleteShader (fragment)</h1>
<ul>
<li><p><a href="https://github.com/shearer12345/graphics_examples_in_git_branches/blob/glTraingleWhiteWithApiTrace/main.cpp#L238">main.cpp line 238 in our C++ code</a></p>
<pre class="c++"><code>for_each(shaderList.begin(), shaderList.end(), glDeleteShader);</code></pre></li>
<li><a href="https://www.opengl.org/sdk/docs/man4/html/glDeleteShader.xhtml">glDeleteShader</a> Deletes a shader object</li>
<li>frees the memory and invalidates the name associated with the shader object specified by shader.</li>
<li><p>in this case our shader with ID=<strong>2</strong> (the fragment shader) is deleted</p></li>
</ul>
<figure>
<img src="assets/apitrace/04_glCreateProgram/12_glDeleteShaderFragment.png" alt="12_glDeleteShaderFragment.png" /><figcaption>12_glDeleteShaderFragment.png</figcaption>
</figure>
</section><section id="gldeleteshader-fragment---context" class="slide level2">
<h1>glDeleteShader (fragment) - context</h1>
<ul>
<li>the shader with ID=<strong>2</strong> (our fragment shader) no longer exists</li>
<li>nothing else has changed</li>
</ul>
<p>TODO - diagram of context, based on <embed src="assets/apitrace/context_draft.jpg_hide" /></p>
</section></section>
<section><section id="apitrace---generate-buffers" class="titleslide slide level1"><h1>Apitrace - Generate Buffers</h1></section><section id="glgenbuffers" class="slide level2">
<h1>glGenBuffers</h1>
<ul>
<li><p><a href="https://github.com/shearer12345/graphics_examples_in_git_branches/blob/glTraingleWhiteWithApiTrace/main.cpp#L243">main.cpp line 243 in our C++ code</a></p>
<pre class="c++"><code>glGenBuffers(1, &amp;positionBufferObject);</code></pre></li>
<li><a href="https://www.opengl.org/sdk/docs/man4/html/glGenBuffers.xhtml">glGenBuffers</a> generate buffer object names</li>
<li>returns n buffer object names in buffers</li>
<li><p>in this case only 1 name is asked for, and return, the ID of buffer object is <strong>1</strong></p></li>
</ul>
<figure>
<img src="assets/apitrace/05_glGenBuffers/01_glGenBuffers.png" alt="01_glGenBuffers.png" /><figcaption>01_glGenBuffers.png</figcaption>
</figure>
</section><section id="glgenbuffers---context" class="slide level2">
<h1>glGenBuffers - context</h1>
<ul>
<li>new buffer objects (in this case just 1) are created</li>
<li>the buffer object is empty</li>
<li>the <strong>ID/name</strong> for the buffer object is stored in the address passed in</li>
<li>nothing else has changed</li>
</ul>
<p>TODO - diagram of context, based on <embed src="assets/apitrace/context_draft.jpg_hide" /></p>
</section><section id="glbindbuffer" class="slide level2">
<h1>glBindBuffer</h1>
<ul>
<li><p><a href="https://github.com/shearer12345/graphics_examples_in_git_branches/blob/glTraingleWhiteWithApiTrace/main.cpp#L245">main.cpp line 245 in our C++ code</a></p>
<pre class="c++"><code>glBindBuffer(GL_ARRAY_BUFFER, positionBufferObject);</code></pre></li>
<li><a href="https://www.opengl.org/sdk/docs/man4/html/glBindBuffer.xhtml">glBindBuffer</a> binds a buffer object to the specified buffer binding point</li>
<li>in this case the buffer object is ID=<strong>1</strong> (our positionBufferObject) is bound as the GL_ARRAY_BUFFER
<ul>
<li>you can see this change in the OpenGL state (parameters tab)</li>
</ul></li>
</ul>
<figure>
<img src="assets/apitrace/05_glGenBuffers/02_glBindBuffer.png" alt="02_glBindBuffer.png" /><figcaption>02_glBindBuffer.png</figcaption>
</figure>
</section><section id="glbindbuffer---context" class="slide level2">
<h1>glBindBuffer - context</h1>
<ul>
<li>the <strong>GL_ARRAY_BUFFER_BINDING</strong> is now set to <strong>1</strong></li>
<li>nothing else has changed</li>
</ul>
<p>TODO - diagram of context, based on <embed src="assets/apitrace/context_draft.jpg_hide" /></p>
</section><section id="glbufferdata" class="slide level2">
<h1>glBufferData</h1>
<ul>
<li><p><a href="https://github.com/shearer12345/graphics_examples_in_git_branches/blob/glTraingleWhiteWithApiTrace/main.cpp#L246">main.cpp line 246 in our C++ code</a></p>
<pre class="c++"><code>glBufferData(GL_ARRAY_BUFFER, sizeof(vertexPositions), vertexPositions, GL_STATIC_DRAW);</code></pre></li>
<li><a href="https://www.opengl.org/sdk/docs/man4/html/glBufferData.xhtml">glBufferData</a> creates and initializes a buffer object's data store.</li>
<li>Takes 4 parameters:
<ul>
<li>target</li>
<li>size</li>
<li>data</li>
<li>usage</li>
</ul></li>
<li>Note the <strong>Vertex Data</strong> tab that now shows in ApiTrace
<ul>
<li>It is the <strong>glBufferData</strong> call that <strong>copies</strong> our CPU data to OpenGL</li>
<li>This data is now visible in the debugger
<ul>
<li>Note: it is just 48 bytes, we can choose how to interpret it</li>
</ul></li>
<li>These are detailed more in the next section</li>
</ul></li>
</ul>
<figure>
<img src="assets/apitrace/05_glGenBuffers/03_glBufferData.png" alt="03_glBufferData.png" /><figcaption>03_glBufferData.png</figcaption>
</figure>
</section><section id="glbufferdata-parameters" class="slide level2">
<h1>glBufferData (parameters)</h1>
<ul>
<li>GLenum target
<ul>
<li>Specifies the target to which the buffer object is bound.</li>
<li>In this case = <strong>GL_ARRAY_BUFFER</strong>, which is used to store vertex attributes</li>
</ul></li>
<li>GLsizeiptr size
<ul>
<li>the size in <strong>bytes</strong> of the buffer object's new data store.</li>
<li>in this case <strong>48</strong> bytes (our array has <strong>12 elements</strong>, each of which are <strong>GL_FLOAT</strong>s (each <strong>32-bits </strong>of precision == <strong>4 bytes</strong>) **12*4=48**</li>
</ul></li>
<li>const GLvoid * data
<ul>
<li>a pointer to data that will be <strong>copied</strong> into the data store for initialization, or NULL if no data is to be copied.</li>
<li>in this case, a pointer to the <strong>vertexPositions</strong> array</li>
</ul></li>
<li>GLenum usage
<ul>
<li>the expected usage pattern of the data store</li>
<li>in this case, <strong>GL_STATIC_DRAW</strong>
<ul>
<li>STATIC means <strong>data store contents will be modified once and used many times.</strong></li>
<li>DRAW means <strong>data store contents are modified by the application, and used as the source for GL drawing and image specification commands.</strong></li>
</ul></li>
</ul></li>
<li>you can see this change in the OpenGL state (parameters tab)</li>
</ul>
</section><section id="glbufferdata-byte-interpretation" class="slide level2">
<h1>glBufferData (byte interpretation)</h1>
<ul>
<li>we can choose how the bytes in the buffer object are interpreted in Vertices</li>
<li>we will have to specify this when we want to use the buffer object for rendering</li>
<li>in the following example, ApiTrace is set to interpret vertices as groups of 4 GL_FLOATS, with a 16 byte jump from one group to the next</li>
</ul>
<figure>
<img src="assets/apitrace/05_glGenBuffers/04_glBufferDataByteInterpretation.png" alt="04_glBufferDataByteInterpretation.png" /><figcaption>04_glBufferDataByteInterpretation.png</figcaption>
</figure>
</section><section id="glbufferdata---context" class="slide level2">
<h1>glBufferData - context</h1>
<ul>
<li>new graphics memory is allocated for the buffer</li>
<li>the graphics memory is <strong>filled</strong> with the bytes from <strong>vertexPositions</strong></li>
<li>nothing else has changed
<ul>
<li>specifically, we <strong>have not</strong> told OpenGL <strong>how</strong> to interpret the bytes</li>
</ul></li>
</ul>
<p>TODO - diagram of context, based on <embed src="assets/apitrace/context_draft.jpg_hide" /></p>
</section><section id="glbindbuffer-unbinding" class="slide level2">
<h1>glBindBuffer (unbinding)</h1>
<ul>
<li><p><a href="https://github.com/shearer12345/graphics_examples_in_git_branches/blob/glTraingleWhiteWithApiTrace/main.cpp#L247">main.cpp line 247 in our C++ code</a></p>
<pre class="c++"><code>glBindBuffer(GL_ARRAY_BUFFER, 0);</code></pre></li>
<li><a href="https://www.opengl.org/sdk/docs/man4/html/glBindBuffer.xhtml">glBindBuffer</a> binds a buffer object to the specified buffer binding point</li>
<li>in this case the buffer object is ID=<strong>0</strong>
<ul>
<li><strong>0</strong> has the meaning on <strong>no buffer</strong>, so no buffer is any longer bound</li>
<li>you can see this change in the OpenGL state (parameters tab)
<ul>
<li>GL_ARRAY_BUFFER_BINDING no longer shows as it is back on its default value</li>
</ul></li>
</ul></li>
</ul>
<figure>
<img src="assets/apitrace/05_glGenBuffers/05_glBindBufferUnbind.png" alt="05_glBindBufferUnbind.png" /><figcaption>05_glBindBufferUnbind.png</figcaption>
</figure>
</section><section id="glbindbuffer-unbinding---context" class="slide level2">
<h1>glBindBuffer (unbinding) - context</h1>
<ul>
<li>the <strong>GL_ARRAY_BUFFER_BINDING</strong> is now set to <strong>0</strong> (meaning no buffer)</li>
<li>nothing else has changed</li>
</ul>
<p>TODO - diagram of context, based on <embed src="assets/apitrace/context_draft.jpg_hide" /></p>
</section></section>
    </div>
  </div>


  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.min.js"></script>

  <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,
        theme: 'sky', // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
//          { src: 'reveal.js/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; }, }
//          { src: 'reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
]});
    </script>
    </body>
</html>
