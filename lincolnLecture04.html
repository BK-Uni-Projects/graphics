<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title></title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="reveal.js/css/reveal.min.css"/>
    <style type="text/css">code{white-space: pre;}</style>
    <link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">
    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
      if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
      }
    </script>
    <!--[if lt IE 9]>
    <script src="reveal.js/lib/js/html5shiv.js"></script>
    <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">


<section><section id="lincoln-lectures-on-graphics---04" class="titleslide slide level1"><h1>Lincoln Lectures On Graphics - 04</h1></section></section>
<section><section id="pipeline-overview" class="titleslide slide level1"><h1>Pipeline Overview</h1></section><section id="putting-the-fun-in-fundamentals" class="slide level2">
<h1>Putting the <strong>&quot;Fun&quot;</strong> in Fundamentals</h1>
</section><section id="vertices-in-world-space" class="slide level2">
<h1>Vertices in World Space</h1>
<p>The pipeline is fed (<em>somehow, we'll cover later</em>) with <strong>vertices</strong> in <strong>WORLD SPACE</strong> (or <strong>Object Space</strong>)</p>
<p><img src="assets/pipelineOverview/pipelineOverview01verticesInWorldSpace.png" alt="pipelineOverview01verticesInWorldSpace" /> </p>
</section><section id="clip-space-transformation" class="slide level2">
<h1>Clip Space Transformation</h1>
<ul>
<li>Transform the vertices into a certain region of space
<ul>
<li>in OpenGL this is called <strong>clip space</strong></li>
</ul></li>
<li>Also known as <strong>projection transformation</strong>
<ul>
<li><a href="http://arcsynthesis.org/gltut/Basics/Intro%20Graphics%20and%20Rendering.html">http://arcsynthesis.org/gltut/Basics/Intro%20Graphics%20and%20Rendering.html</a></li>
<li>you get to <strong>program</strong> this bit (GLSL - vertex shader)</li>
</ul></li>
</ul>
<p><img src="assets/pipelineOverview/worldSpaceToClipSpace.png" alt="worldSpaceToClipSpace" /> </p>
</section><section id="homogeneous-coordinates" class="slide level2">
<h1>Homogeneous Coordinates!!</h1>
<ul>
<li>X,Y,Z and W!!!
<ul>
<li>W defines what the extents of clip space are for this vertex (-W to W on X, Y, Z)</li>
</ul></li>
<li>The process of transforming vertices into clip space is arbitrary (stupid)
<ul>
<li>OpenGL provides a lot of flexibility in this step</li>
<li>i.e. <strong>programmable</strong> flexibility!</li>
</ul></li>
<li>We'll cover homogeneous coordinates more later
<ul>
<li>http://www.tomdalling.com/blog/modern-opengl/explaining-homogenous-coordinates-and-projective-geometry/</li>
<li>http://www.songho.ca/math/homogeneous/homogeneous.html</li>
</ul></li>
</ul>
</section><section id="vertices-in-clip-space" class="slide level2">
<h1>Vertices in Clip Space</h1>
<p><img src="assets/pipelineOverview/pipelineOverview02verticesInClipSpace.png" alt="pipelineOverview02verticesInClipSpace" /> </p>
</section><section id="clipping" class="slide level2">
<h1>Clipping</h1>
<ul>
<li>Triangles not <strong>fully</strong> in <strong>clip space</strong> (the [-1,1] cube) we want to <strong>clip</strong></li>
</ul>
<p><img src="assets/pipelineOverview/clipping.png" alt="clipping" /> </p>
</section><section id="clipping-2" class="slide level2">
<h1>Clipping 2</h1>
<ul>
<li>Points are easy to test in our new, normalised coordinate space (NDC)</li>
<li>Lines are more difficult</li>
<li>Triangles are complicated
<ul>
<li>may need to make more triangles</li>
</ul></li>
</ul>
</section><section id="vertices-in-normalized-device-coordinates" class="slide level2">
<h1>Vertices in Normalized Device Coordinates</h1>
<p><img src="assets/pipelineOverview/pipelineOverview03verticesThatHaveBeenClipped.png" alt="pipelineOverview03verticesThatHaveBeenClipped" /> </p>
</section><section id="normalized-device-coordinates" class="slide level2">
<h1>Normalized Device Coordinates</h1>
<ul>
<li>Clip space is interesting, but inconvenient
<ul>
<li>the extent of this space is different for each vertex, which makes visualizing a triangle rather difficult</li>
</ul></li>
<li>The X, Y, and Z of each vertex's position is divided by W to get normalized device coordinates
<ul>
<li>basically the same as clip space except that the range of X, Y and Z are <strong>[-1, 1]</strong></li>
</ul></li>
</ul>
</section><section id="vertices-in-ndc" class="slide level2">
<h1>Vertices in NDC</h1>
<p><img src="assets/pipelineOverview/pipelineOverview04verticesInNormalizedDeviceCoordinates.png" alt="pipelineOverview04verticesInNormalizedDeviceCoordinates" /> </p>
</section><section id="window-transformation" class="slide level2">
<h1>Window Transformation</h1>
<ul>
<li>Transform from normalized device coordinates towindow coordinates</li>
<li>window coordinates are relative to the window that OpenGL is running within</li>
<li>Though they refer to the window, they are still three dimensional coordinates
<ul>
<li>still floating-point values</li>
<li>still have a z-coordinates!! Why?? Stay-tuned ...</li>
<li>bottom-left position is the origin (0, 0)</li>
</ul></li>
</ul>
</section><section id="vertices-in-window-coordinates" class="slide level2">
<h1>Vertices in Window Coordinates</h1>
<p><img src="assets/pipelineOverview/pipelineOverview05verticesInWindowCoordinates.png" alt="pipelineOverview05verticesInWindowCoordinates" /> </p>
</section><section id="scan-conversion" class="slide level2">
<h1>Scan Conversion</h1>
<ul>
<li>After conversion to window coordinates the triangle undergoes a process called <strong>scan conversion</strong>
<ul>
<li>also known as <strong>rasterization</strong></li>
</ul></li>
<li>Takes the triangle and generates fragments that cover the area of the triangle
<ul>
<li>also fills in pixels for lines</li>
</ul></li>
<li>We'll look later at how scan conversion can be done</li>
</ul>
</section><section id="scan-conversion-triangles-again" class="slide level2">
<h1>Scan Conversion (triangles again)</h1>
<ul>
<li>Image in the centre shows the digital grid of output pixels
<ul>
<li>the circles represent the centre of each pixel, the centre of each pixel represents a <strong>sample</strong>:
<ul>
<li>a discrete location within the area of a pixel</li>
</ul></li>
</ul></li>
</ul>
<p><img src="assets/pipelineOverview/scanline.png" alt="scanline" /> </p>
</section><section id="scan-conversion-more-triangles" class="slide level2">
<h1>Scan Conversion (more triangles)</h1>
<ul>
<li>During scan conversion, a triangle will produce a <strong>fragment</strong> for every pixel sample that is within the 2D area of the triangle (right)
<ul>
<li>a rough <strong>approximation</strong> of the triangle's general shape</li>
</ul></li>
</ul>
<p><img src="assets/pipelineOverview/scanline.png" alt="scanline" /> </p>
</section><section id="scan-conversion-1" class="slide level2">
<h1>Scan Conversion</h1>
<section id="shared-edges-and-the-invariance-guarantee-by-tom-clancy" class="level3">
<h3>Shared Edges and <strong><em>the invariance guarantee</em></strong> (By Tom Clancy)</h3>
<ul>
<li>triangles that share edges are very often rendered (unless you’re making asteroids)</li>
<li>OpenGL offers the invariance guarantee
<ul>
<li>so long as shared edge vertex positions are <strong>identical</strong>, there will be no sample gaps during scan conversion</li>
</ul></li>
<li>What would happen otherwise??</li>
</ul>
<p><img src="assets/pipelineOverview/sharededge.png" alt="sharededge" /> </p>
</section>
</section><section id="scan-conversion-still" class="slide level2">
<h1>Scan Conversion (Still??)</h1>
<ul>
<li>Scan conversion only uses X and Y position of the triangle in window coordinates to determine which fragments to generate
<ul>
<li>the Z value is not forgotten!</li>
</ul></li>
<li>The result of scan converting a triangle is a sequence of fragments that cover the shape of the triangle
<ul>
<li>each fragment has data associated with it
<ul>
<li>the 2D location of the fragment in window coordinates</li>
<li>the Z position of the fragment</li>
<li>(a.k.a. known as the depth of the fragment)</li>
<li>there may be other information that is part of a fragment</li>
</ul></li>
</ul></li>
</ul>
</section><section id="fragments" class="slide level2">
<h1>Fragments</h1>
<p><img src="assets/pipelineOverview/pipelineOverview06fragments.png" alt="pipelineOverview06fragments" /> </p>
</section><section id="fragment-processing" class="slide level2">
<h1>Fragment Processing</h1>
<ul>
<li>Fragment processing takes a fragment from scan converted triangle and <strong>transforms</strong> it into</li>
<li>one or more colour values</li>
<li>a single depth value (z value)</li>
<li>you get to <strong>program</strong> this bit (GLSL - fragment shader)</li>
<li>The order that fragments from a single triangle are processed in is irrelevant
<ul>
<li><em>unlike</em> the order that triangles are pumped into the pipeline, a single triangle lies in a <strong>single plane</strong> so fragments generated from it <strong>cannot overlap</strong></li>
</ul></li>
<li><strong>However</strong>, the fragments from another triangle might</li>
<li><strong><em>Therefore, fragments from one triangle must all be processed before fragments from another triangle</em></strong></li>
</ul>
</section><section id="processed-fragments" class="slide level2">
<h1>Processed Fragments</h1>
<p><img src="assets/pipelineOverview/pipelineOverview07fragmentsProcessed.png" alt="pipelineOverview07fragmentsProcessed" /> </p>
</section><section id="fragment-writing-maybe" class="slide level2">
<h1>Fragment Writing (maybe)</h1>
<ul>
<li>After generating one or more colours and a depth value
<ul>
<li>the fragment is <strong>possibly</strong> written to the destination (probably a frame buffer)</li>
<li><strong>What might control this?</strong></li>
</ul></li>
<li>This step involves more than simply writing to the destination image
<ul>
<li>These will be covered more later</li>
</ul></li>
</ul>
</section></section>
<section><section id="colours" class="titleslide slide level1"><h1>Colours</h1></section><section id="colours-1" class="slide level2">
<h1>Colours</h1>
<ul>
<li>The usual description of a colour is as a series of numbers on the range <strong>[0, 1] </strong><em>Why [0,1]?</em>
<ul>
<li>each of the numbers corresponds to the <strong>intensity</strong> of a particular reference colour</li>
<li>the final colour represented by the series of numbers is a mix of these reference colours</li>
</ul></li>
<li>The set of reference colours is called a <strong>colour space</strong>.
<ul>
<li>the most common colour space for screens is RGB, where the reference colours are Red, Green and Blue</li>
<li>printed works tend to use CMYK (Cyan, Magenta, Yellow, Black)]</li>
</ul></li>
</ul>
<p><img src="assets/pipelineOverview/RGB_and_CMYK_comparison.png" alt="RGB_and_CMYK_comparison" /> </p>
</section><section id="colours-2" class="slide level2">
<h1>Colours 2</h1>
<ul>
<li>Combining different intensities of this 3 colours, we can generate and display millions of different colour shades in OpenGL
<ul>
<li>how many colours? what is the usual representation?
<ul>
<li><a href="http://en.wikipedia.org/wiki/Color_depth#Deep_color_.2830.2F36.2F48-bit.29" class="uri">http://en.wikipedia.org/wiki/Color_depth#Deep_color_.2830.2F36.2F48-bit.29</a></li>
</ul></li>
<li>in most conditions more than the human eye can perceive
<ul>
<li>any <em>special conditions?</em></li>
</ul></li>
<li>unless you're a tetrachromat ... <a href="http://www.post-gazette.com/pg/06256/721190-114.stm" class="uri">http://www.post-gazette.com/pg/06256/721190-114.stm</a></li>
</ul></li>
</ul>
</section></section>
<section><section id="shaders" class="titleslide slide level1"><h1>Shaders</h1></section><section id="shaders-1" class="slide level2">
<h1>Shaders</h1>
<ul>
<li>A shader is a program designed to be run on a renderer as part of the rendering operation</li>
<li>Regardless of the kind of rendering system in use, shaders can only be executed at certain points in the rendering process</li>
<li>These shader stages represent hooks where we can insert our code to create specific visual effects, for example:
<ul>
<li>transformation of an incoming vertex to clip space is a useful hook for user-defined code</li>
<li>the processing of a fragment into final colours and depth</li>
</ul></li>
</ul>
</section><section id="shaders-2-glsl" class="slide level2">
<h1>Shaders 2 (GLSL)</h1>
<ul>
<li>Shaders for OpenGL are run on the actual rendering hardware so free up valuable CPU time for other tasks
<ul>
<li>and <strong>usually</strong> the graphics card has orders of magnitude more raw, though specialist processing power available</li>
<li>GeForce GTX 760 Ti - <strong>2460 GFLOPS</strong> single-precision!!</li>
</ul></li>
<li>Or perform operations that would be difficult if not impossible without the flexibility of executing arbitrary code
<ul>
<li>however, they live within certain limits that CPU code would not have to ...</li>
<li>?? any guess what limits ??</li>
</ul></li>
<li>There are a number of shading languages available to various APIs. The one used here is the primary shading language of OpenGL, the <strong>OpenGL Shading Language</strong>, or <strong>GLSL</strong>. for short
<ul>
<li>It looks deceptively like C, <strong>but it is very much not C</strong></li>
</ul></li>
</ul>
</section><section id="shaders-3-glsl" class="slide level2">
<h1>Shaders 3 (GLSL)</h1>
<pre class="glsl"><code>#version 330

layout(location = 0) in vec4 position;
uniform float loopDuration;
uniform float time;

void main()
{
    float timeScale = 3.14159f * 2.0f / loopDuration;
    
    float currTime = mod(time, loopDuration);
    vec4 totalOffset = vec4(
        cos(currTime * timeScale) * 0.5f,
        sin(currTime * timeScale) * 0.5f,
        0.0f,
        0.0f);

    gl_Position = position + totalOffset;
}</code></pre>
</section></section>
<section><section id="stepping-through-gltrianglewhite" class="titleslide slide level1"><h1>Stepping through glTriangleWhite</h1></section><section id="stepping-through-gltrianglewhite-1" class="slide level2">
<h1>Stepping through glTriangleWhite</h1>
<ul>
<li>We'll walk through all the code for <code>glTriangleWhite</code>
<ul>
<li>it's just main.cpp that we're interested in</li>
<li><a href="https://github.com/shearer12345/graphics_examples_in_git_branches/blob/glTriangleWhite/main.cpp" class="uri">https://github.com/shearer12345/graphics_examples_in_git_branches/blob/glTriangleWhite/main.cpp</a></li>
</ul></li>
<li>We'll walk through starting at the global variables, then the entry point (main)</li>
</ul>
</section></section>
<section><section id="code-in-execution-order-here-also" class="titleslide slide level1"><h1>Code in execution order here also</h1></section></section>
<section><section id="global-variables" class="titleslide slide level1"><h1>Global Variables</h1></section><section id="sdl-variables" class="slide level2">
<h1>SDL Variables</h1>
<pre class="c++"><code>SDL_Window *win; //pointer to the SDL_Window
SDL_GLContext context; //the SDL_GLContext
GLuint theProgram; //GLuint that we&#39;ll fill in to refer to the GLSL program (only have 1 at this point)</code></pre>
</section><section id="string-holding-the-source-of-our-vertex-shader" class="slide level2">
<h1>string holding the <strong>source</strong> of our vertex shader</h1>
<pre class="c++"><code>//string holding the **source** of our vertex shader, to save loading from a file
const std::string strVertexShader(
    &quot;#version 330\n&quot;
    &quot;layout(location = 0) in vec4 position;\n&quot;
    &quot;void main()\n&quot;
    &quot;{\n&quot;
    &quot;   gl_Position = position;\n&quot;
    &quot;}\n&quot;
    );</code></pre>
</section><section id="string-holding-the-source-of-our-fragment-shader" class="slide level2">
<h1>string holding the <strong>source</strong> of our fragment shader</h1>
<pre class="c++"><code>//string holding the **source** of our fragment shader, to save loading from a file
const std::string strFragmentShader(
    &quot;#version 330\n&quot;
    &quot;out vec4 outputColor;\n&quot;
    &quot;void main()\n&quot;
    &quot;{\n&quot;
    &quot;   outputColor = vec4(1.0f, 1.0f, 1.0f, 1.0f);\n&quot;
    &quot;}\n&quot;
    );</code></pre>
</section><section id="our-variables" class="slide level2">
<h1>our variables</h1>
<pre class="c++"><code>const float vertexPositions[] = {
    0.0f, 0.5f, 0.0f, 1.0f,
    -0.4330127f, -0.25f, 0.0f, 1.0f,
    0.4330127f, -0.25f, 0.0f, 1.0f,
};</code></pre>
</section><section id="our-opengl-variables" class="slide level2">
<h1>our OpenGL variables</h1>
<pre class="c++"><code>GLuint theProgram; //GLuint that we&#39;ll fill in to refer to the GLSL program (only have 1 at this point)
GLuint positionBufferObject;
GLuint vao;</code></pre>
<ul>
<li>note the variable <code>theProgram</code> is actually higher up in the source, but is more sensible here</li>
</ul>
</section></section>
<section><section id="main" class="titleslide slide level1"><h1>main</h1></section><section id="main-page-1---setup" class="slide level2">
<h1>main (page 1 - setup)</h1>
<pre class="c++"><code>int main( int argc, char* args[] )
{

    //setup
    //- do just once
    initialise();
    createWindow();
    setGLAttributes();
    createContext();
    initGlew();


    //load stuff from files
    //- usually do just once
    loadAssets();</code></pre>
</section><section id="main-page-2---loop" class="slide level2">
<h1>main (page 2 - loop)</h1>
<pre class="c++"><code>    //LOOP FROM HERE - PLACEHOLDER

        //GET INPUT HERE - PLACEHOLDER

        //UPDATE SIMULATION - PLACEHOLDER

        glClear(GL_COLOR_BUFFER_BIT);

        render(); //RENDER HERE - PLACEHOLDER
        
        SDL_GL_SwapWindow(win);; //present the frame buffer to the display (swapBuffers)

    //LOOP TO HERE - PLACEHOLDER
</code></pre>
</section><section id="main-page-3---close" class="slide level2">
<h1>main (page 3 - close)</h1>
<pre class="c++"><code>    //not looping, so delay so we can see what it does
    SDL_Delay(2000); //Wait for 2 seconds before exiting

    
    //cleanup and exit
    cleanUp();
    SDL_Quit();

    return 0;
}</code></pre>
</section></section>
<section><section id="setup" class="titleslide slide level1"><h1>setup</h1></section><section id="initialise" class="slide level2">
<h1>initialise</h1>
<pre class="c++"><code>void initialise()
{
    if (SDL_Init(SDL_INIT_EVERYTHING) != 0){
        cout &lt;&lt; &quot;SDL_Init Error: &quot; &lt;&lt; SDL_GetError() &lt;&lt; std::endl;
        exit(1);
    }
    cout &lt;&lt; &quot;SDL initialised OK!\n&quot;;
}</code></pre>
</section><section id="createwindow" class="slide level2">
<h1>createWindow</h1>
<pre class="c++"><code>void createWindow()
{
    win = SDL_CreateWindow(&quot;Hello World!&quot;, 100, 100, 600, 600, SDL_WINDOW_OPENGL); //same height and width makes the window square ...
    if (win == nullptr)
    {
        std::cout &lt;&lt; &quot;SDL_CreateWindow Error: &quot; &lt;&lt; SDL_GetError() &lt;&lt; std::endl;
        SDL_Quit();
        exit(1);
    }
    cout &lt;&lt; &quot;SDL CreatedWindow OK!\n&quot;;
}</code></pre>
</section><section id="setglattributes" class="slide level2">
<h1>setGLAttributes</h1>
<pre class="c++"><code>void setGLAttributes()
{
    // set the opengl context version
    int major = 3;
    int minor = 3;
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, major);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, minor);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE); //core profile
    cout &lt;&lt; &quot;Set OpenGL context to version &quot; &lt;&lt; major &lt;&lt; &quot;.&quot; &lt;&lt; minor &lt;&lt; &quot; OK!\n&quot;;
}</code></pre>
</section><section id="createcontext" class="slide level2">
<h1>createContext</h1>
<pre class="c++"><code>
void createContext()
{
    context = SDL_GL_CreateContext(win);
    if (context == nullptr){
        SDL_DestroyWindow(win);
        std::cout &lt;&lt; &quot;SDL_GL_CreateContext Error: &quot; &lt;&lt; SDL_GetError() &lt;&lt; std::endl;
        SDL_Quit();
        exit(1);
    }
    cout &lt;&lt; &quot;Created OpenGL context OK!\n&quot;;
}</code></pre>
</section><section id="initglew" class="slide level2">
<h1>initGlew</h1>
<pre class="c++"><code>void initGlew()
{
    GLenum rev;
    glewExperimental = GL_TRUE; //GLEW isn&#39;t perfect - see https://www.opengl.org/wiki/OpenGL_Loading_Library#GLEW
    rev = glewInit();
    if (GLEW_OK != rev){
        std::cout &lt;&lt; &quot;GLEW Error: &quot; &lt;&lt; glewGetErrorString(rev) &lt;&lt; std::endl;
        SDL_Quit();
        exit(1);
    }
    else {
        cout &lt;&lt; &quot;GLEW Init OK!\n&quot;;
    }
}</code></pre>
</section></section>
<section><section id="load-assets" class="titleslide slide level1"><h1>Load Assets</h1></section><section id="load-assets-1" class="slide level2">
<h1>Load Assets</h1>
<pre class="c++"><code>void loadAssets()
{
    initializeProgram(); //create GLSL Shaders, link into a GLSL program

    initializeVertexBuffer(); //load data into a vertex buffer

    glGenVertexArrays(1, &amp;vao); //create a Vertex Array Object
    glBindVertexArray(vao); //make the VAO active
    cout &lt;&lt; &quot;Vertex Array Object created OK! GLUint is: &quot; &lt;&lt; vao &lt;&lt; std::endl;

    cout &lt;&lt; &quot;Loaded Assets OK!\n&quot;;
}</code></pre>
</section></section>
    </div>
  </div>


  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.min.js"></script>

  <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,
        theme: 'sky', // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
//          { src: 'reveal.js/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; }, }
//          { src: 'reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
]});
    </script>
    </body>
</html>
