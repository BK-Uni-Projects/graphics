<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title></title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="reveal.js/css/reveal.min.css"/>
    <style type="text/css">code{white-space: pre;}</style>
    <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
    </style>
    <link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">
    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
      if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
      }
    </script>
    <!--[if lt IE 9]>
    <script src="reveal.js/lib/js/html5shiv.js"></script>
    <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">


<section><section id="lincoln-lectures-on-graphics---08" class="titleslide slide level1"><h1>Lincoln Lectures On Graphics - 08</h1></section></section>
<section><section id="transformations-and-3d" class="titleslide slide level1"><h1>Transformations and 3D</h1></section><section id="where-we-are" class="slide level2">
<h1>Where we are</h1>
<ul>
<li>with the workshops and the lecture content you should now be beginning to be comfortable with:
<ul>
<li>the pipeline model of rendering</li>
<li>how to setup OpenGL for rendering</li>
<li>how to tell OpenGL how to use the data you've supplied it</li>
<li>how to load data into OpenGL</li>
<li>what shaders do
<ul>
<li>specifically, the generic data each type of shader takes in and passes out</li>
</ul></li>
<li>how to pass data into shaders
<ul>
<li>as attributes, and uniforms</li>
</ul></li>
<li>how to move an object around using GLM and matrices</li>
</ul></li>
</ul>
</section></section>
<section><section id="matrix-matrix-product" class="titleslide slide level1"><h1>Matrix-Matrix product</h1></section><section id="matrix-matrix-product---generic" class="slide level2">
<h1>Matrix-Matrix product - generic</h1>
<ul>
<li>Last time we said that transformation matrices can be applied to vectors (through Matrix-Vector multiplication).</li>
<li>By itself this seems like overkill
<ul>
<li>It took far less effort to do a translation and scaling by hand than with matrices</li>
</ul></li>
<li>BUT, we want to apply these transformations to thousands or millions of vertices</li>
<li>so, we need things to be efficient and still flexible</li>
<li>This is the real power of matrices
<ul>
<li>we can combine <strong>as many transformations as we want</strong> into a single matrix</li>
<li>by multiplying the matrices together</li>
</ul></li>
<li>to allow the most complex transformations to any vertex with a simple (matrix) multiplication</li>
</ul>
</section><section id="matrix-matrix-product-1" class="slide level2">
<h1>Matrix-Matrix product</h1>
<ul>
<li>product, just means multiplication</li>
<li>remember - we can only multiple matrices where the following are equal</li>
<li>width of the first matrix</li>
<li>height of the second matrix</li>
<li>the <strong>dot</strong> just means multiply</li>
</ul>
</section><section id="ready-..." class="slide level2">
<h1>ready? ...</h1>
</section><section id="matrix-matrix-product-4x4" class="slide level2">
<h1>Matrix-Matrix product!! 4x4</h1>
<figure>
<img src="assets/matrixMatrix_4x4_Product.png" alt="matrixMatrix_4x4_Product.png" /><figcaption>matrixMatrix_4x4_Product.png</figcaption>
</figure>
</section><section id="matrix-vector-product---2x2" class="slide level2">
<h1>Matrix-Vector product - 2x2</h1>
<ul>
<li>the 4x4 is pretty overwhelming</li>
<li>let's briefly look at a 2x2 to get a handle on this</li>
<li>with some fixed numbers</li>
</ul>
<figure>
<img src="assets/matrixMatrix_2x2_Product.png" alt="matrixMatrix_2x2_Product.png" /><figcaption>matrixMatrix_2x2_Product.png</figcaption>
</figure>
</section><section id="lets-try" class="slide level2">
<h1>Let's try</h1>
<ul>
<li>we'll try to create a <strong>single</strong> matrix that
<ul>
<li>scales a given vector by (2,2,2)</li>
<li>then translates it by (1,2,3)</li>
</ul></li>
<li>NOTE: we want to scale the vector first, but the scale transformation comes last in the multiplication.</li>
<li>Pay attention to this when combining transformations or you'll get the opposite of what you've asked for.</li>
<li>To figure out the transformation from the vectors perspective, read the transformation from the vector to the <strong>LEFT!!</strong></li>
</ul>
<figure>
<img src="assets/matrixMatrix_4x4_Product_translateByScale.png" alt="matrixMatrix_4x4_Product_translateByScale.png" /><figcaption>matrixMatrix_4x4_Product_translateByScale.png</figcaption>
</figure>
</section><section id="test-it" class="slide level2">
<h1>Test it</h1>
<ul>
<li>let's apply that to a test vector</li>
</ul>
<figure>
<img src="assets/matrixMatrix_4x4_Product_translateByScale_applied.png" alt="matrixMatrix_4x4_Product_translateByScale_applied.png" /><figcaption>matrixMatrix_4x4_Product_translateByScale_applied.png</figcaption>
</figure>
</section></section>
<section><section id="matrix-matrix-product-in-practice" class="titleslide slide level1"><h1>Matrix-Matrix product in practice</h1></section><section id="matrix-matrix-product-in-practice-1" class="slide level2">
<h1>Matrix-Matrix product in practice</h1>
<ul>
<li>both GLM (CPU-side) and GLSL (GPU-side) support Matrix-Matrix multiplication</li>
<li>GLM has a whole bunch of methods to support creating matrices for specific cases, including:
<ul>
<li>rotation</li>
<li>translation</li>
<li>scale</li>
<li>setting up a viewpoint</li>
<li>setting up a perspective view</li>
</ul></li>
<li>we're finally heading towards 3D</li>
</ul>
</section><section id="d" class="slide level2">
<h1>3D?</h1>
<ul>
<li>in fact, <strong>everything</strong> we've been doing so far has <strong>already</strong> been in 3D</li>
<li>we just were only creating triangles, and usually just with a constant z-value</li>
<li>to see 3D things we need to:
<ul>
<li>use different z-values</li>
<li>usually create solid-looking objects
<ul>
<li>out of collections of triangles</li>
</ul></li>
<li>usually create some kind of perspective view so that objects (triangles) further away appear smaller</li>
</ul></li>
<li>see branch glmRotateColorCube</li>
</ul>
</section><section id="model-transformation" class="slide level2">
<h1><strong>Model</strong> transformation</h1>
<ul>
<li>this control of the position, orientation and scale of an object is called the <strong>Model</strong> transformation</li>
<li>we generically call the matrix to represent this the:
<ul>
<li><strong>ModelMatrix</strong></li>
<li>it's job is to represent the position, orientation and scale of an object</li>
<li>but not anything about the viewpoint, or the projection</li>
<li>there are other matrices we use for that</li>
<li><strong>separation of concerns</strong></li>
</ul></li>
</ul>
</section><section id="lets-try-this-is-the-cube" class="slide level2">
<h1>Let's try this is the Cube</h1>
<ul>
<li>can we translate and rotate it?</li>
<li>what <strong>exactly</strong> do we want to happen?</li>
</ul>
<p>Note: live-code. <code>git checkout glmRotateColorCube</code> and make changes to match <code>glmRotateAndTranslateColorCube</code></p>
</section><section id="what-was-that-diff" class="slide level2">
<h1>What was that diff?</h1>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">git</span> diff glmRotateColorCube glmRotateAndTranslateColorCube</code></pre>
<pre class="sourceCode diff"><code class="sourceCode diff"><span class="kw">diff --git a/main.cpp b/main.cpp</span>
index 7313fda..4d7c709 100644
<span class="dt">--- a/main.cpp</span>
<span class="dt">+++ b/main.cpp</span></code></pre>
</section><section id="section" class="slide level2">
<h1></h1>
<pre class="sourceCode diff"><code class="sourceCode diff"><span class="dt">@@ -31,11 +31,11 @@ const std::string strVertexShader(</span>
    #endif
    &quot;in vec4 position;\n&quot;
    &quot;in vec4 color;\n&quot;
<span class="st">-   &quot;uniform mat4 rotateMatrix;\n&quot;</span>
<span class="ot">+   &quot;uniform mat4 modelMatrix;\n&quot;</span>
    &quot;smooth out vec4 theColor;\n&quot;
    &quot;void main()\n&quot;
    &quot;{\n&quot;
<span class="st">-   &quot;   gl_Position = rotateMatrix * position;\n&quot; //multiple the position by the transformation matrix (rotate)</span>
<span class="ot">+   &quot;   gl_Position = modelMatrix * position;\n&quot; //multiple the position by the transformation matrix (rotate)</span>
    &quot;   theColor = color;\n&quot; //just pass on the color. It&#39;s a **smooth**, so will be interpolated
    &quot;}\n&quot;
    );</code></pre>
</section><section id="section-1" class="slide level2">
<h1></h1>
<pre class="sourceCode diff"><code class="sourceCode diff"><span class="dt">@@ -165,16 +165,20 @@ const float vertexData[] = {</span>
 };
 
 //the rotate we&#39;ll pass to the GLSL
<span class="st">-glm::mat4 rotateMatrix; // the transformation matrix for our object - which is the identity matrix by default</span>
<span class="st">-float rotateSpeed = 1.0f; //rate of change of the rotate - in radians per second</span>
<span class="ot">+glm::mat4 modelMatrix; // the transformation matrix for our object - which is the identity matrix by default</span>
 
<span class="ot">+glm::mat4 rotationMatrix; // the rotationMatrix for our object - which is the identity matrix by default</span>
<span class="ot">+glm::mat4 translationMatrix; // the translationMatrix for our object - which is the identity matrix by default</span>
<span class="ot">+</span>
<span class="ot">+float rotateSpeed = 1.0f; //rate of change of the rotate - in radians per second</span>
<span class="ot">+glm::vec3 translateSpeed = glm::vec3(0.1f, 0.1f, 0.0f);</span></code></pre>
</section><section id="section-2" class="slide level2">
<h1></h1>
<pre class="sourceCode diff"><code class="sourceCode diff">
 //our GL and GLSL variables
 
 GLuint theProgram; //GLuint that we&#39;ll fill in to refer to the GLSL program (only have 1 at this point)
 GLint positionLocation; //GLuint that we&#39;ll fill in with the location of the `position` attribute in the GLSL
 GLint colorLocation; //GLuint that we&#39;ll fill in with the location of the `color` attribute in the GLSL
<span class="st">-GLint rotateMatrixLocation; //GLuint that we&#39;ll fill in with the location of the `rotateMatrix` variable in the GLSL</span>
<span class="ot">+GLint modelMatrixLocation; //GLuint that we&#39;ll fill in with the location of the `modelMatrix` variable in the GLSL</span>
 
 GLuint vertexBufferObject;
 GLuint vao;</code></pre>
</section><section id="section-3" class="slide level2">
<h1></h1>
<pre class="sourceCode diff"><code class="sourceCode diff"><span class="dt">@@ -342,7 +346,7 @@ void initializeProgram()</span>
 
    positionLocation = glGetAttribLocation(theProgram, &quot;position&quot;);
    colorLocation = glGetAttribLocation(theProgram, &quot;color&quot;);
<span class="st">-   rotateMatrixLocation = glGetUniformLocation(theProgram, &quot;rotateMatrix&quot;);</span>
<span class="ot">+   modelMatrixLocation = glGetUniformLocation(theProgram, &quot;modelMatrix&quot;);</span>
    //clean up shaders (we don&#39;t need them anymore as they are no in theProgram
    for_each(shaderList.begin(), shaderList.end(), glDeleteShader);
 }</code></pre>
</section><section id="section-4" class="slide level2">
<h1></h1>
<pre class="sourceCode diff"><code class="sourceCode diff"><span class="dt">@@ -383,12 +387,18 @@ void updateSimulation(double simLength) //update simulation with an amount of ti</span>
    //calculate the amount of rotate for this timestep
    float rotate = (float)simLength * rotateSpeed; //simlength is a double for precision, but rotateSpeedVector in a vector of float, alternatively use glm::dvec3
 
<span class="st">-   //modify the rotateMatrix with the rotate, as a rotate, around the z-axis</span>
<span class="ot">+   //modify the rotationMatrix with the rotate, as a rotate, around the z-axis</span>
    const glm::vec3 unitX = glm::vec3(1, 0, 0);
    const glm::vec3 unitY = glm::vec3(0, 1, 0);
    const glm::vec3 unitZ = glm::vec3(0, 0, 1);
    const glm::vec3 unit45 = glm::normalize(glm::vec3(0, 1, 1));
<span class="st">-   rotateMatrix = glm::rotate(rotateMatrix, rotate, unit45);</span>
<span class="ot">+   </span>
<span class="ot">+   rotationMatrix = glm::rotate(rotationMatrix, rotate, unit45);</span></code></pre>
</section><section id="section-5" class="slide level2">
<h1></h1>
<pre class="sourceCode diff"><code class="sourceCode diff"><span class="ot">+</span>
<span class="ot">+   glm::vec3 translate = float(simLength) * translateSpeed; //scale the translationSpeed by time to get the translation amount</span>
<span class="ot">+   translationMatrix = glm::translate(translationMatrix, translate);</span>
<span class="ot">+</span>
<span class="ot">+   modelMatrix = translationMatrix * rotationMatrix;</span>
 }
 
 void render()</code></pre>
</section><section id="section-6" class="slide level2">
<h1></h1>
<pre class="sourceCode diff"><code class="sourceCode diff"><span class="dt">@@ -396,7 +406,7 @@ void render()</span>
    glUseProgram(theProgram); //installs the program object specified by program as part of current rendering state
 
    //load data to GLSL that **may** have changed
<span class="st">-   glUniformMatrix4fv(rotateMatrixLocation, 1, GL_FALSE, glm::value_ptr(rotateMatrix)); //uploaed the rotateMatrix to the appropriate uniform location</span>
<span class="ot">+   glUniformMatrix4fv(modelMatrixLocation, 1, GL_FALSE, glm::value_ptr(modelMatrix)); //uploaed the modelMatrix to the appropriate uniform location</span>
               // upload only one matrix, and don&#39;t transpose it
 
     size_t colorData = sizeof(vertexData) / 2;</code></pre>
</section><section id="section-7" class="slide level2">
<h1></h1>
<pre class="sourceCode diff"><code class="sourceCode diff"><span class="dt">@@ -438,7 +448,7 @@ int main( int argc, char* args[] )</span>
    loadAssets();
 
 
<span class="st">-   while (!done &amp;&amp; (SDL_GetTicks() &lt; 5000)) //LOOP FROM HERE, for 2000ms (or if done flag is set)</span>
<span class="ot">+   while (!done &amp;&amp; (SDL_GetTicks() &lt; 15000)) //LOOP FROM HERE, for 2000ms (or if done flag is set)</span>
        //WARNING: SDL_GetTicks is only accurate to milliseconds, use SDL_GetPerformanceCounter and SDL_GetPerformanceFrequency for higher accuracy
    {
        //GET INPUT HERE - PLACEHOLDER</code></pre>
</section><section id="why-doing-the-4x4-matrix-multiplication-cpu-side-with-glm" class="slide level2">
<h1>Why doing the 4x4 Matrix multiplication CPU-side (with GLM)?</h1>
<ul>
<li>isn't that less efficient?</li>
<li>YES</li>
<li>but usually we need to know the effect of the transformations CPU-side
<ul>
<li>(for collision detection, for example)</li>
<li>it means we pass less into GLSL</li>
<li>we can change to calculations we do CPU-side more easily than GPU-side</li>
<li>if we want now to combine 3 matrices that's easy in C++,</li>
<li>to do it GPU-side, we'd need to change
<ul>
<li>the C++</li>
<li>the uniforms of the GLSL</li>
<li>the main of the GLSL</li>
</ul></li>
</ul></li>
</ul>
</section><section id="why-doing-the-4x4-matrix-multiplication-cpu-side-with-glm-1" class="slide level2">
<h1>Why doing the 4x4 Matrix multiplication CPU-side (with GLM)?</h1>
<ul>
<li>Except for the most common (frequency) 4x4 matrix multiplcations</li>
<li><strong>projectionMatrix * viewMatrix * modelMatrix</strong></li>
<li>Which we'll look at next week</li>
</ul>
</section></section>
    </div>
  </div>


  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.min.js"></script>

  <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,
        theme: 'sky', // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
//          { src: 'reveal.js/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; }, }
//          { src: 'reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
]});
    </script>
    </body>
</html>
