<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="shearer12345" />
  <title>lincoln Lectures On Graphics - 02</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="reveal.js/css/reveal.min.css"/>
    <style type="text/css">code{white-space: pre;}</style>
    <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
    </style>
    <link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">
    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
      if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
      }
    </script>
    <!--[if lt IE 9]>
    <script src="reveal.js/lib/js/html5shiv.js"></script>
    <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section>
    <h1 class="title">lincoln Lectures On Graphics - 02</h1>
    <h2 class="author">shearer12345</h2>
    <h3 class="date"></h3>
</section>

<section id="assessment-methods-and-weighting" class="slide level1">
<h1>Assessment Methods and Weighting</h1>
<ul>
<li>Assignment (Coursework)
<ul>
<li>weighting = 70%</li>
</ul></li>
<li>Exam (Closed-book)
<ul>
<li>weighting = 30%</li>
</ul></li>
<li>From the Module Specification - Graphics 2015-16
<ul>
<li>Blackboard=&gt;Graphics (CGP2012M)-&gt;About this module</li>
</ul></li>
</ul>
</section>
<section class="slide level1">

<h2 id="learning-outcomes">Learning Outcomes</h2>
<ul>
<li>Both assessments assess both Learning Outcomes</li>
<li><p>Learning Outcome 1</p>
<blockquote>
<p>design and develop interactive 3D graphics software, applying appropriate mathematical/algorithmic techniques for efficient 2D and 3D graphics</p>
</blockquote></li>
<li><p>Learning Outcome 2</p>
<blockquote>
<p>Demonstrate deep understanding of computer graphics programming techniques and approaches</p>
</blockquote></li>
<li><p>Both are <em>individually</em> assessed</p></li>
</ul>
</section>
<section class="slide level1">

<h2 id="what-to-expect-in-the-assignment">What to expect in the assignment</h2>
<ul>
<li>based around developing an interactive 3D scenario
<ul>
<li>such as a simple computer game:
<ul>
<li>Pong</li>
<li>Space Invaders</li>
<li>Virtual plane</li>
</ul></li>
</ul></li>
<li>will submit to blackboard, but live-demo in the following workshop, affording:
<ul>
<li>faster mark turn around</li>
<li>immediate verbal feedback</li>
<li>written feedback with mark release</li>
<li>opportunity to ask questions</li>
</ul></li>
</ul>
</section>
<section class="slide level1">

<h2 id="what-features-in-the-assignment-will-be-assessed">What features in the assignment will be assessed</h2>
<ul>
<li>aims to assess practical capability in writing programs that generate 3D graphics and updating the 3D scene based on human input</li>
<li>requires a set of basic 3D graphics features, such as:
<ul>
<li>3D geometry</li>
<li>3D (perspective) projections</li>
<li>moving/rotating objects</li>
<li>moving/rotating view points</li>
<li>coloured objects</li>
<li>advanced features, such as:
<ul>
<li>lighting simulation</li>
<li>texturing.</li>
</ul></li>
</ul></li>
</ul>
</section>
<section class="slide level1">

<h2 id="what-to-expect-on-the-exam">What to expect on the Exam</h2>
<ul>
<li>will assess the more theorectical side of computer graphics</li>
<li>wider understanding of the area</li>
<li>questions on the following would be appropriate (examplar, other questions could occur):
<ul>
<li>how standard algorithms or techniques work</li>
<li>the factors that affect the performance of graphical systems</li>
<li>writing graphics &quot;shaders&quot; from scratch</li>
<li>or critique/modify/correct provided &quot;shaders&quot;</li>
</ul></li>
</ul>
</section>
<section id="recommended-reading-for-graphics" class="slide level1">
<h1>Recommended Reading for Graphics</h1>
<ul>
<li>Learning Modern 3D Graphics Programming by Jason L. McKesson</li>
<li><p>http://www.arcsynthesis.org/gltut/ #It's Triangles All The Way Down</p></li>
<li>Remember: Everything is a shell</li>
<li>All of these shells are made of triangles</li>
<li>Even surfaces that appear to be round are merely triangles if you look closely enough</li>
<li>There are techniques that generate more triangles for objects that appear closer or larger, so that the viewer can almost never see the faceted silhouette of the object, but they are always made of triangles</li>
<li><p>Note: Some rasterizers use planar quadrilaterals: four-sided objects, where all of the lines lie in the same plane. One of the reasons that hardware-based rasterizers always use triangles is that all of the lines of a triangle are guaranteed to be in the same plane. Knowing this makes the rasterization process less complicated.</p></li>
</ul>
<figure>
<img src="assets\triangle.png" alt="triangle" /><figcaption>triangle</figcaption>
</figure>
</section>
<section id="objects" class="slide level1">
<h1>Objects</h1>
<ul>
<li>An object is made out of a collection of adjacent triangles that define the outer surface of the object</li>
<li>Such a collection of triangles is often called:
<ul>
<li>a model</li>
<li>a mesh</li>
<li>geometry</li>
<li><strong>these terms are used interchangeably</strong></li>
</ul></li>
</ul>
</section>
<section id="pipeline" class="slide level1">
<h1>Pipeline</h1>
<ul>
<li>Rasterization has several phases ordered into a pipeline</li>
<li>triangles enter from the left and a 2D image is filled in at the right</li>
<li>A pipeline is very ammeneable to hardware acceleration</li>
<li>it operates on each triangle one at a time, in a specific order</li>
<li>triangles can be fed into the left of the pipeline while triangles that were sent earlier can still be in some phase of rasterization.</li>
</ul>
</section>
<section class="slide level1">

<h2 id="opengl-pipeline">OpenGL Pipeline</h2>
<figure>
<img src="assets\pipeline01.png" alt="http://goanna.cs.rmit.edu.au/~gl/teaching/Interactive3D/2011/lecture2.html" /><figcaption>http://goanna.cs.rmit.edu.au/~gl/teaching/Interactive3D/2011/lecture2.html</figcaption>
</figure>
</section>
<section class="slide level1">

<h2 id="raster-ordering">Raster Ordering</h2>
<ul>
<li>The order in which triangles and the various meshes are submitted to the rasterizer can affect its output
<ul>
<li>(if you are doing fancy stuff)</li>
</ul></li>
<li>No matter how you submit the triangular mesh data, the rasterizer will process each triangle in a specific order:
<ul>
<li>drawing the next one only when the previous triangle has finished being drawn</li>
</ul></li>
</ul>
</section>
<section class="slide level1">

<h2 id="triangles-and-vertices-in-opengl">Triangles and Vertices (in OpenGL)</h2>
<ul>
<li>Triangles consist of 3 vertices
<ul>
<li>A vertex is a collection of arbitrary data</li>
<li>???!!!???</li>
<li>For the sake of simplicity, in our context this data must contain a point in three dimensional space - it may contain other data (e.g. colour)</li>
</ul></li>
<li>Any 3 points that are not on the same line create a triangle
<ul>
<li>A triangle is defined by exactly 3 (three-dimensional) points - (X, Y, Z)</li>
</ul></li>
</ul>
</section>
<section id="what-is-opengl" class="slide level1">
<h1>What Is OpenGL?</h1>
<ul>
<li>A real API</li>
<li>There are a number of languages that have implemented it
<ul>
<li>but it all comes back to C in the end</li>
</ul></li>
<li>and guess what language weâ€™re running the course in?</li>
<li>The API, in C, is defined by a number of <code>typedefs</code>, <code>#defined</code> enumerator values, and <code>functions</code>
<ul>
<li><code>typedefs</code> define basic GL types like <code>GLint</code>, <code>GLfloat</code> and so forth</li>
<li>Complex aggregates like structs are never directly exposed in OpenGL</li>
</ul></li>
</ul>
</section>
<section class="slide level1">

<h2 id="cc-and-opengl">C/C++ and OpenGL</h2>
<pre class="sourceCode c"><code class="sourceCode c">structObject{
    <span class="dt">int</span> anInteger;
    <span class="dt">float</span> aFloat;
    <span class="dt">char</span> *aString;
};

<span class="co">//Create the storage for the object.</span>
ObjectnewObject;

<span class="co">//Put data into the object.</span>
newObject.anInteger= <span class="dv">5</span>;
newObject.aFloat= <span class="fl">0.</span>4f;
newObject.aString= <span class="st">&quot;Some String&quot;</span>;</code></pre>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//Create the storage for the object</span>
GLuintobjectName;
glGenObject(<span class="dv">1</span>, &amp;objectName);

<span class="co">//Put data into the object.</span>
glBindObject(GL_MODIFY,objectName);
glObjectParameteri(GL_MODIFY, GL_OBJECT_AN_INTEGER, <span class="dv">5</span>);
glObjectParameterf(GL_MODIFY, GL_OBJECT_A_FLOAT, <span class="fl">0.</span>4f);
glObjectParameters(GL_MODIFY, GL_OBJECT_A_STRING, <span class="st">&quot;Some String&quot;</span>);</code></pre>
</section>
<section class="slide level1">

<h2 id="explaining-c-and-opengl">Explaining C and OpenGL</h2>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//Create the storage for the object</span>
GLuintobjectName;
glGenObject(<span class="dv">1</span>, &amp;objectName);

<span class="co">//Put data into the object.</span>
glBindObject(GL_MODIFY,objectName);
glObjectParameteri(GL_MODIFY, GL_OBJECT_AN_INTEGER, <span class="dv">5</span>);
glObjectParameterf(GL_MODIFY, GL_OBJECT_A_FLOAT, <span class="fl">0.</span>4f);
glObjectParameters(GL_MODIFY, GL_OBJECT_A_STRING, <span class="st">&quot;Some String&quot;</span>);</code></pre>
<ul>
<li>Not actual OpenGL commands but..</li>
<li>OpenGL owns the storage for all OpenGL objects
<ul>
<li>the user can only access an object by reference.</li>
<li>almost all OpenGL objects are referred to by an unsigned integer (theGLuint)
<ul>
<li>?? OMG !!</li>
</ul></li>
</ul></li>
</ul>
</section>
<section class="slide level1">

<h2 id="explaining-c-and-opengl-1">Explaining C and OpenGL</h2>
<pre class="sourceCode c"><code class="sourceCode c">GLuintobjectName;
glGenObject(<span class="dv">1</span>, &amp;objectName);

<span class="co">//Put data into the object.</span>
glBindObject(GL_MODIFY,objectName);
glObjectParameteri(GL_MODIFY, GL_OBJECT_AN_INTEGER, <span class="dv">5</span>);
glObjectParameterf(GL_MODIFY, GL_OBJECT_A_FLOAT, <span class="fl">0.</span>4f);
glObjectParameters(GL_MODIFY, GL_OBJECT_A_STRING, <span class="st">&quot;Some String&quot;</span>);</code></pre>
<ul>
<li>Objects are created by a function of the form<code>glGen*</code>, where * is the type of the object</li>
<li><code>glGen*(No.of objects to create)</code>
<ul>
<li><code>GLuint*</code> array that receives the newly created object names</li>
</ul></li>
</ul>
</section>
<section class="slide level1">

<h2 id="explaining-c-and-opengl-2">Explaining C and OpenGL</h2>
<pre class="sourceCode c"><code class="sourceCode c">GLuintobjectName;
glGenObject(<span class="dv">1</span>, &amp;objectName);

<span class="co">//Put data into the object.</span>
glBindObject(GL_MODIFY,objectName);
glObjectParameteri(GL_MODIFY, GL_OBJECT_AN_INTEGER, <span class="dv">5</span>);
glObjectParameterf(GL_MODIFY, GL_OBJECT_A_FLOAT, <span class="fl">0.</span>4f);
glObjectParameters(GL_MODIFY, GL_OBJECT_A_STRING, <span class="st">&quot;Some String&quot;</span>);</code></pre>
<ul>
<li>To modify most objects, they must first be <strong>bound</strong> to thecontext</li>
<li><code>GL_BindObject(Thefictitious targetisthelocation where, ObjectNameisbound)</code></li>
<li>Many objects can be bound to different locations in the context; this allows the same object to be used in different ways</li>
</ul>
</section>
<section class="slide level1">

<h2 id="explaining-c-and-opengl-3">Explaining C and OpenGL</h2>
<pre class="sourceCode c"><code class="sourceCode c">GLuintobjectName;
glGenObject(<span class="dv">1</span>, &amp;objectName);

<span class="co">//Put data into the object.</span>
glBindObject(GL_MODIFY,objectName);
glObjectParameteri(GL_MODIFY, GL_OBJECT_AN_INTEGER, <span class="dv">5</span>);
glObjectParameterf(GL_MODIFY, GL_OBJECT_A_FLOAT, <span class="fl">0.</span>4f);
glObjectParameters(GL_MODIFY, GL_OBJECT_A_STRING, <span class="st">&quot;Some String&quot;</span>);</code></pre>
<ul>
<li>Functions that actually change values within the object are given a target parameter, so that they could modify objects bound to different targets</li>
<li><code>glObjectParameterf(GL_MODIFY, An integer that points to an object, A new float value)</code></li>
<li>Note: All OpenGL objects are not as simple as this example, and the functions that change object state do <strong>not all follow</strong> these naming conventions</li>
</ul>
</section>
<section class="slide level1">

<h2 id="the-structure-of-opengl">The Structure of OpenGL</h2>
<ul>
<li>The OpenGLAPI is defined as a statemachine</li>
<li>Almost all of the OpenGL functions set or retrieve some state in OpenGL
<ul>
<li>the only functions that do not change state are functions that use the currently set state to cause rendering to happen</li>
<li>(<em>except a bunch of other functions that we'll pretend don't exist</em>)</li>
</ul></li>
<li>Think of the state machine as a very large <code>struct</code> with a great many different fields called the <em>OpenGL context</em>
<ul>
<li>each field in the context represents some information necessary for rendering</li>
</ul></li>
</ul>
</section>
<section class="slide level1">

<h2 id="the-structure-of-opengl-1">The Structure of OpenGL</h2>
<ul>
<li>Objects in OpenGL are thus defined as a list of fields in thisstructthat can be saved and restored</li>
<li>Binding an object to a target within the context causes the data in this object to replace some of the context's state.</li>
<li>Afterhe binding, future function calls that read from or modify this context state will read or modify the state within the object.</li>
</ul>
</section>
<section class="slide level1">

<h2 id="objects-in-opengl">Objects in OpenGL</h2>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">//Create the storage for the object</span>
GLuintobjectName;
glGenObject(<span class="dv">1</span>, &amp;objectName);

<span class="co">//Put data into the object.</span>
glBindObject(GL_MODIFY,objectName);
glObjectParameteri(GL_MODIFY,GL_OBJECT_AN_INTEGER, <span class="dv">5</span>);
glObjectParameterf(GL_MODIFY, GL_OBJECT_A_FLOAT, <span class="fl">0.</span>4f);
glObjectParameters(GL_MODIFY, GL_OBJECT_A_STRING, <span class="st">&quot;Some String&quot;</span>);</code></pre>
<ul>
<li>Objects are usually represented as <code>GLuint</code> integers
<ul>
<li>these are handles to the actual OpenGLobjects</li>
</ul></li>
<li>The integer value 0 is special; it acts as the object equivalent of a <code>NULL</code> pointer
<ul>
<li>binding object 0 means to unbind the currently boundobject</li>
</ul></li>
<li>This means that the original context state, the state that was in place before the binding took place, now becomes the context state</li>
</ul>
</section>
<section id="the-openglspecification" class="slide level1">
<h1>The OpenGLSpecification</h1>
<ul>
<li>the specification defines
<ul>
<li>the initial OpenGLstate</li>
<li>what each function does to change or retrieve it</li>
<li>what happens when you call a rendering function</li>
</ul></li>
<li>The most important thing to understand about the specification is it describes results, not implementation</li>
<li>The specification is written by the OpenGL Architectural Review Board (ARB)
<ul>
<li>a group of representatives from companies like Apple, NVIDIA, and AMD (the ATI part), among others</li>
<li>The ARB is part of the <strong>Khronos Group</strong></li>
</ul></li>
</ul>
</section>
<section id="the-openglspecification-1" class="slide level1">
<h1>The OpenGLSpecification</h1>
<ul>
<li>The OpenGL ARB controls the specification, but it does not control OpenGL's code</li>
<li>It is up to the developers of that hardware to write an OpenGL Implementation for that hardware</li>
<li>Who controls the OpenGL implementation is different for different operatingsystems:
<ul>
<li>on Windows, OpenGL implementations are controlled virtually entirely by the hardware makers themselves</li>
<li>on Mac OSX, OpenGL implementations are controlled byApple</li>
</ul></li>
<li>The upshot of this is if you are writing a program and it seems to be exhibiting off-spec behaviour, the fault is with the maker of your OpenGL implementation</li>
</ul>
</section>
<section class="slide level1">

<h2 id="and-finally-just-for-fun...">And finally, just for fun...</h2>
<ul>
<li>There are many versions of the OpenGL Specification</li>
<li>OpenGL versions are not like most Direct3D versions, which typically change most of the API</li>
<li>Code that works on one version of OpenGL will almost always work on later versions ofOpenGL</li>
</ul>
</section>
    </div>
  </div>


  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.min.js"></script>

  <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,
        theme: 'moon', // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
//          { src: 'reveal.js/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; }, }
//          { src: 'reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
]});
    </script>
    </body>
</html>
